;; ================================================================ ;;
;;                                                                  ;;
;;   PaGe :: Parser Generator for LALR(1)-grammar by Common Lisp    ;;
;;                                                                  ;;
;; ================================================================ ;;

;; (defpackage :page
;;   (:use :cl-user))
;; (in-package 'page)

(defstruct (grammar
	    (:constructor make-grammar (start rules)))
  start (rules () :type list))


;; 
;; grammar represented by numbers (and symbol-number table)
;; 
(defstruct (canonical-grammar
	    (:conc-name cg-)
	    (:constructor make-canonical-grammar
	      (start rules nt-num t-num sym-array sym-alist unknown-symbol)))
  (start :type number)
  (rules :type list)
  (nt-num :type number)
  (t-num :type number)
  (sym-array :type array)
  (sym-alist :type list)
  unknown-symbol
  (nullable-array nil)			; bit array
  (first-array nil)
  (follow-array nil)
  )

(defstruct (rule
	    (:constructor make-rule (lhs rhs)))
  id
  (lhs :type number)
  (rhs :type list))

(defun rule-equal-p (r1 r2)
  (= (rule-id r1) (rule-id r2)))


(defun canonicalize (grammar &key start eof (unknown-symbol ""))
  (let* ((ntset (remove-duplicates (mapcar #'car (grammar-rules grammar)) :test #'equal))
	 (tset (set-difference (remove-duplicates (apply #'append (mapcar #'cdr (grammar-rules grammar))) :test #'equal) ntset :test #'equal))
	 (symbol-alist nil)
	 (nt-num 1)
	 (t-num 0))
    ;; numbering to non-terminal symbol
    (loop for symbol in ntset
	  do (push (cons symbol nt-num) symbol-alist)
	     (incf nt-num))
    (setf t-num nt-num)
    ;; numbering to terminal symbol
    (loop for symbol in tset
	  do (push (cons symbol t-num) symbol-alist)
	     (incf t-num))
    ;; make symbol-array and canonical-grammar
    (let ((symbol-array (make-array (+ t-num 1) :initial-element nil))
	  (rules (cons (make-rule 0 (list (cdr (assoc (grammar-start grammar) symbol-alist :test #'equal)) t-num))
		       (mapcar #'(lambda (rule) (let ((r (mapcar #'(lambda (x) (cdr (assoc x symbol-alist :test #'equal))) rule))) (make-rule (car r) (cdr r)))) (grammar-rules grammar)))))
      (dolist (sym-num symbol-alist)
	(setf (aref symbol-array (cdr sym-num)) (car sym-num)))
      (setf (aref symbol-array 0) start (aref symbol-array t-num) eof)
      ;; replace symbol to index
      (make-canonical-grammar
       (cdr (assoc (grammar-start grammar) symbol-alist :test #'equal))
       (let ((n 0)) (mapc #'(lambda (rule) (setf (rule-id rule) n) (incf n)) rules) rules)
       nt-num t-num symbol-array symbol-alist unknown-symbol))))



(defun cg-symbol (cg n &key (unknown t))
  (declare (canonical-grammar cg))
  (if (<= n (cg-t-num cg))
      (aref (cg-sym-array cg) n)
      (when unknown (cg-unknown-symbol cg))))

(defun cg-nullable (cg n)
  (declare (canonical-grammar cg))
  (unless (cg-nullable-array cg) (calc-nullable cg))
  (= 1 (aref (cg-nullable-array cg) n)))

(defun cg-first (cg n)
  (declare (canonical-grammar cg))
  (unless (cg-first-array cg) (calc-first cg))
  (aref (cg-first-array cg) n))

(defun cg-follow (cg n)
  (declare (canonical-grammar cg))
  (unless (cg-follow-array cg) (calc-follow cg))
  (aref (cg-follow-array cg) n))

(defun cg-non-terminal-p (cg num)
  (declare (canonical-grammar cg))
  (< num (cg-nt-num cg)))

(defun cg-terminal-p (cg num)
  (declare (canonical-grammar cg))
  (<= (cg-nt-num cg) num))

;; (defun rule-lhs (rule) (car rule))
;; (defun rule-rhs (rule) (cdr rule))

(defun foldl (e op l)
  (if l (foldl (funcall op e (first l)) op (rest l)) e))

(defun filter (predicate sequence)
  (when sequence
    (destructuring-bind (x . ls) sequence
      (if (funcall predicate x)
	  (cons x (filter predicate ls))
	  (filter predicate ls)))))

(defun take (n l)
  (if (< 0 n) (cons (first l) (take (- n 1) (rest l))) nil))
      
(defun drop (n l)
  (if (< 0 n) (drop (- n 1) (rest l)) l))

(defun set-eq (s1 s2 &key (test #'equal))
  (null (set-exclusive-or s1 s2 :test test)))



;; nullability-checker
(defun calc-nullable (cg)
  (let ((nullable (make-array (+ (cg-t-num cg) 1) :element-type 'bit :initial-element 0))
	(changed t))
    ;; initialize
    (loop while changed
	  do (setf changed nil)
	     (dolist (rule (cg-rules cg))
	       (when (or (null (rule-rhs rule)) ; X -> 
			 (every #'(lambda (n) (= 1 (aref nullable n))) (rule-rhs rule))) ; X -> Y_1 .. Y_n s.t. all Y_i is nullable.
		 ;; only false -> true
		 (when (= 0 (aref nullable (rule-lhs rule)))
		   (setf (aref nullable (rule-lhs rule)) 1
			 changed t)))))
    (setf (cg-nullable-array cg) nullable)))

(defun cg-sequence-nullable (cg sequence)
  (let ((nullable t))
    (loop while nullable
	  for s in sequence
	  do (setf nullable (cg-nullable cg s)))
    nullable))

;; assoc using equal
(defun assoceq (item alist)
  (assoc item alist :test #'equal))

;; 
(defun calc-first (cg)
  (let ((firsts (make-array (+ (cg-t-num cg) 1) :initial-element '()))
	(changed t))
    (loop for n from (cg-nt-num cg) to (cg-t-num cg)
	  do (setf (aref firsts n) (list n)))
    (loop while changed
	  do (setf changed nil)
	     (dotimes (X (cg-nt-num cg))
	       (let ((old-x-firsts (copy-list (aref firsts X))))
		 ;; all [X -> Y_1 .. Y_n]s
		 (dolist (rule (cg-rules cg))
		   (when (= X (rule-lhs rule))
		     (let ((all-null t))
		       (loop while all-null
			     for Y in (rule-rhs rule)
			     do (let ((y-firsts (aref firsts Y))
				      (null-exists nil))
				  (dolist (symbol y-firsts)
				    (if (null symbol)
					(setf null-exists t)
					(pushnew symbol (aref firsts X) :test #'=)))
				  ;; if nil isn't in y-firsts, we don't have to look rest [Y_i]s.
				  (unless null-exists (setf all-null nil))))
		       ;; n = 0 or all Y_i's firsts has nil.
		       (when all-null
			 (pushnew nil (aref firsts X) :test #'equal)))))
		 (unless (set-eq old-x-firsts (aref firsts X))
		   (setf changed t)))))
    (setf (cg-first-array cg) firsts)))
		     
(defun nt-derive-first (cg symbol &optional (seen nil))
  (let ((rules (cg-rules cg))
	(result nil))
    (dolist (rule rules result)
      (when (and (= symbol (rule-lhs rule))
		 (rule-rhs rule))
	(let ((X (first (rule-rhs rule))))
	  (when (and (cg-non-terminal-p cg X)
		     (not (member X seen)))
	    (pushnew X result)
	    (setf result (union result (nt-derive-first cg X (cons symbol seen))))))))))
	

		 
	


(defun cg-sequence-first (cg sequence)
  (if (null sequence) nil
      (let ((firsts (cg-first cg (first sequence))))
	(if (member () firsts)
	    (union firsts (cg-sequence-first cg (rest sequence)))
	    firsts))))

(defun calc-follow (cg)
  (let ((follows (make-array (+ (cg-t-num cg) 1) :initial-element nil))
	(changed t))
    (push (cg-t-num cg) (aref follows (cg-start cg)))
    (loop while changed
	  do (setf changed nil)
	     (dolist (rule (cg-rules cg))
	       (let ((A (rule-lhs rule)))
		 (labels ((f (symbol-list)
			    (let ((B (first symbol-list)))
			      (when (cg-non-terminal-p  cg B)
				(let ((rest-firsts (cg-sequence-first cg (rest symbol-list))))
				  ;; [ A -> aB ] or [ A -> aBb /\ () in First(b) ]
				  (when (or (null rest-firsts) (member nil rest-firsts :test #'equal))
				    (dolist (symbol (aref follows A))
				      (unless (member symbol (aref follows B))
					(push symbol (aref follows B))
					(setf changed t))))
				  (dolist (symbol rest-firsts)
				    (unless (or (null symbol) (member symbol (aref follows B) :test #'equal))
				      (push symbol (aref follows B))
				      (setf changed t))))))))
		   (maplist #'f (rule-rhs rule))))))
    (setf (cg-follow-array cg) follows)))
  


;; --------------------------------
;;  LR parser
;; 

;; Parser
(defstruct (parser
	    (:constructor make-parser (num states goto action)))
  num
  states
  goto
  (action nil))

;; lr-item
(defstruct (item 
	    (:constructor make-item (rule position)))
  (rule :type rule)
  (position :type number)
  (%pre :undefined)
  (%suc :undefined))
  ;; (lhs 0 :type number)
  ;; (rhs-pre nil :type list)
  ;; (rhs-suc nil :type list))
(defun item-lhs (item) (rule-lhs (item-rule item)))
(defun item-rhs (item) (rule-rhs (item-rule item)))
(defun item-pre (item)
  (if (eq :undefined (item-%pre item))
      (setf (item-%pre item) (take (item-position item) (item-rhs item)))
      (item-%pre item)))
(defun item-suc (item)
  (if (eq :undefined (item-%suc item))
      (setf (item-%suc item) (drop (item-position item) (item-rhs item)))
      (item-%suc item)))

;; (defun make-item (lhs rhs-pre rhs-suc) (list lhs rhs-pre rhs-suc))

(defun shift-item (item)
  (make-item
   (item-rule item)
   (+ (item-position item) 1)))

(declaim (inline item-equal-p))
(defun item-equal-p (i1 i2)
  (declare (type item i1 i2))
  (and (= (item-position i1) (item-position i2))
       (rule-equal-p (item-rule i1) (item-rule i2))))

;; closure for lr(0)-item
(defun lr0-closure (cg state)
  (let ((rules (cg-rules cg))
	(looked-symbols nil)
	(changed t))
    (loop while changed
	  do (setf changed nil)
	     (dolist (item state)
	       (declare (type item item) (type list state))
	       (let ((X (nth (item-position item) (item-rhs item))))
		 (when (and (numberp X)
			    (not (member X looked-symbols))
			    (cg-non-terminal-p cg X))
		     (push X looked-symbols)
		     (setf changed t)
		     (dolist (rule rules)
		       (when (= X (rule-lhs rule))
			 (push (make-item rule 0) state)))))))
    state))

;; lr0-goto
(defun lr0-goto (cg state symbol &key (closure nil))
  (let ((result nil))
    (dolist (item state)
      (when (< (item-position item) (length (item-rhs item)))
	(let ((X (nth (item-position item) (item-rhs item))))
	  (when (= symbol X)
	    (pushnew (shift-item item) result :test #'item-equal-p))
	  
	  (dolist (rule (cg-rules cg))
	    (when (and (rule-rhs rule)
		       (= symbol (first (rule-rhs rule)))
		       (member (rule-lhs rule) (nt-derive-first cg X)))
	      (pushnew (make-item rule 1) result :test #'item-equal-p))))))
    (if closure
	(lr0-closure cg result)
	result)))
	  
    ;; (lr0-closure cg (mapcar #'shift-item (reverse result)))))

(defun state-equal-p (s1 s2)
  (declare (list s1 s2))
  (do ((x s1 (rest x)) (y s2 (rest y)))
      ((or (eq x y) (null x) (null y)) (eq x y))
    (unless (item-equal-p (first x) (first y))
      (return nil))))
  ;; (declare (list s1 s2))
  ;; (set-eq s1 s2 :test #'item-equal-p))

;; make lr0-parse table
(defun lr0-kernels (cg)
  (let* ((init (list (make-item (first (cg-rules cg)) 0)))
	 (num 0)
	 (state-ht (make-hash-table :test 'state-equal-p))
	 (state-array (make-array 1 :fill-pointer 0 :adjustable t))
	 (goto-array (make-array 1 :fill-pointer 1 :adjustable t :initial-element nil))
	 (changed t))
    (setf (gethash init state-ht) 0)
    (setf (aref state-array 0) init)
    (loop while changed
	  do (setf changed nil)
	     (loop for n from 0 to num
		   do (let ((I (aref state-array n)))
			(dotimes (m (cg-t-num cg))
			  (let ((X (+ m 1)))
			    (let ((next-state (lr0-goto cg I X)))
			      (when next-state
				(setf next-state (sort next-state #'(lambda (x y) (cond ((< (rule-id (item-rule x)) (rule-id (item-rule y))) t)
											((= (rule-id (item-rule x)) (rule-id (item-rule y)))
											 (<= (item-position x) (item-position y)))
											(t nil)))))
				(let ((next-num (gethash next-state state-ht nil)))
				  (when (null next-num)
				    (incf num)
				    (setf next-num num)
				    (vector-push-extend next-state state-array)
				    (setf (gethash next-state state-ht) next-num)
				    (vector-push-extend () goto-array))
				  (unless (member (cons X next-num) (aref goto-array n)
						  :test #'(lambda (x y) (and (= (car x) (car y)) (= (cdr x) (cdr y)))))
				    (push (cons X next-num) (aref goto-array n))
				    (setf changed t))))))))))
    (make-parser (+ num 1) state-array goto-array nil)))

(defun lr0-parse-table (cg)
  (let* ((init (lr0-closure cg (list (make-item (first (cg-rules cg)) 0))))
	 (num 0)
	 (state-ht (make-hash-table :test 'state-equal-p))
	 (state-array (make-array 1 :fill-pointer 0 :adjustable t))
	 (goto-array (make-array 1 :fill-pointer 1 :adjustable t :initial-element nil))
	 (changed t))
    (setf (gethash init state-ht) 0)
    (setf (aref state-array 0) init)
    (loop while changed
	  do (setf changed nil)
	     (loop for n from 0 to num
		   do (let ((I (aref state-array n)))
			(dotimes (m (cg-t-num cg))
			  (let ((X (+ m 1)))
			    (let ((next-state (lr0-goto cg I X :closure t)))
			      (when next-state
				(setf next-state (sort next-state #'(lambda (x y) (cond ((< (rule-id (item-rule x)) (rule-id (item-rule y))) t)
											((= (rule-id (item-rule x)) (rule-id (item-rule y)))
											 (<= (item-position x) (item-position y)))
											(t nil)))))
				(let ((next-num (gethash next-state state-ht nil)))
				  (when (null next-num)
				    (incf num)
				    (setf next-num num)
				    (vector-push-extend next-state state-array)
				    (setf (gethash next-state state-ht) next-num)
				    (vector-push-extend () goto-array))
				  (unless (member (cons X next-num) (aref goto-array n)
						  :test #'(lambda (x y) (and (= (car x) (car y)) (= (cdr x) (cdr y)))))
				    (push (cons X next-num) (aref goto-array n))
				    (setf changed t))))))))))
    (make-parser (+ num 1) state-array goto-array nil)))

;; ;; --------------------------------
;; ;;  DeRemer's method
;; ;; 
;; (defun direct-read-set (cg parser)
;;   (let ((dr nil))
;;     (dotimes (n (parser-num parser) dr)
;;       (dolist (arrow (aref (parser-goto parser) n))
;; 	(destructuring-bind (symbol . num) arrow
;; 	  (when (< symbol (cg-nt-num cg))
;; 	    (push (cons (cons n symbol)
;; 			(mapcar #'car (remove-if #'(lambda (arrow) (cg-non-terminal-p cg (car arrow))) (aref (parser-goto parser) num))))
;; 		  dr)))))))

;; ;; checker
;; ;; (defun check-dr-set (cg)
;; ;;   (mapcar
;; ;;    #'(lambda (x) (cons (cons (caar x) (cg-symbol cg (cdar x)))
;; ;; 		       (mapcar #'(lambda (y) (cg-symbol cg y)) (cdr x))))
;; ;;    (dr-set cg (lr0-parse-table cg))))

;; ;; DONE
;; (defun rel-reads (cg parser)
;;   (let ((goto (parser-goto parser))
;; 	(result nil))
;;     (dotimes (n (parser-num parser) result)
;;       (loop for symbol from 1 to (cg-nt-num cg)		; X
;; 	    do (let ((next (cdr (assoc symbol (aref goto n))))) ; I -X-> ..
;; 		 (when next
;; 		   (push (cons (cons n symbol)
;; 			       (mapcar #'(lambda (x) (cons next (car x)))
;; 				       (filter #'(lambda (arrow) (and (car arrow) (cg-nullable cg (car arrow)))) (aref goto next))))
;; 			 result)))))))

;; ;; algorithm; Digraph
;; (defun alg-digraph (node-list rel base-f)
;;   (let ((result-f nil)
;; 	(stack nil)
;; 	(depth 0)
;; 	(nar (make-hash-table :test #'equal)))
;;     (dolist (node node-list) (push (cons node nil) result-f))
;;     (labels ((traverse (x)
;; 	       (push x stack)
;; 	       (incf depth)
;; 	       (setf (gethash x nar) depth)
;; 	       (setf (cdr (assoceq x result-f)) (cdr (assoceq x base-f)))
;; 	       (dolist (y (cdr (assoceq x rel)))
;; 		 (when (= 0 (gethash y nar 0)) (traverse y))
;; 		 (setf (gethash x nar) (min (gethash x nar 0) (gethash y nar 0)))
;; 		 (setf (cdr (assoceq x result-f)) (union (cdr (assoceq x result-f)) (cdr (assoceq y result-f)))))
;; 	       (when (= depth (gethash x nar 0))
;; 		 (loop do (setf (gethash (first stack) nar) most-positive-fixnum)
;; 		       until (equal x (pop stack))))))
;;       (dolist (node node-list result-f)
;; 	(when (= 0 (gethash node nar 0)) (traverse node))))))

;; (defun detect-loop (rel x &key (visited nil) (test #'eql))
;;   ;; (format t "[~a,~a,~a,~a]~%" rel x visited test)
;;   (let ((found nil))
;;     (loop until found
;; 	  for s in (cdr (assoc x rel :test test))
;; 	  do (if (member x visited :test test)
;; 		 (setf found t)
;; 		 (setf found (detect-loop rel s :visited (cons x visited) :test test))))
;;     found))
  
;; (defun transition-list (parser)
;;   (let ((node-list nil))
;;     (dotimes (n (parser-num parser) node-list)
;;       ;; (format t "~a,~a:~a~%" n (aref (parser-goto parser) n) node-list)
;;       (setf node-list (append (mapcar #'(lambda (arrow) (cons n (car arrow))) (aref (parser-goto parser) n)) node-list)))))

;; ;; ;; Read(p,A)
;; (defun read-set (cg parser)
;;   (let* ((nt-transitions (filter #'(lambda (transition) (cg-non-terminal-p cg (cdr transition)))
;; 				 (transition-list parser))))
;;     ;; making node-list
;;     (alg-digraph nt-transitions (rel-reads cg parser) (direct-read-set cg 
;; parser))))

;; (defun rev-traverse (parser starts sequence)
;;   (if sequence
;;       (let ((preds nil))
;; 	(dotimes (n (parser-num parser))
;; 	  (when (intersection (mapcar #'(lambda (x) (cons (first sequence) x)) starts)
;; 			      (aref (parser-goto parser) n) :test #'equal)
;; 	    (push n preds)))
;; 	(rev-traverse parser preds (rest sequence)))
;;       starts))


;; (defun rel-includes (cg parser)
;;   (let* ((rules (cg-rules cg))
;; 	 (nt-transitions (filter #'(lambda (transition) (cg-non-terminal-p cg (cdr transition)))
;; 				 (transition-list parser)))
;; 	 (result nil))
;;     (dolist (transition nt-transitions)	; transition = (p, A)
;;       (dolist (rule rules)		; rule = X -> aYb
;; 	(let ((rhs (copy-list (rule-rhs rule)))
;; 	      (pre nil))
;; 	  (loop while rhs
;; 		do (when (and (= (first rhs) (cdr transition))
;; 			      (cg-sequence-nullable cg (rest rhs)))
;; 		     (let* ((starts (rev-traverse parser (list (car transition)) pre))
;; 			    (available (intersection (mapcar #'(lambda (x) (cons x (rule-lhs rule))) starts)
;; 						     nt-transitions
;; 						     :test #'equal)))
;; 		       (if (assoceq (cons (car transition) (first rhs)) result)
;; 			   (setf (cdr (assoceq transition result))
;; 				 (union available (cdr (assoceq transition result))) )
;; 			   (push (cons transition available) result))))
;; 		   (push (pop rhs) pre)))))
;;     result))

;; (defun follow-set (cg parser)
;;   (let* ((nt-transitions (filter #'(lambda (transition) (cg-non-terminal-p cg (cdr transition)))
;; 				 (transition-list parser))))
;;     (alg-digraph nt-transitions (rel-includes cg parser) (read-set cg parser))))

;; (defun rel-lookback (parser)
;;   (let ((result nil))
;;     (dotimes (n (parser-num parser))
      
;;       (dolist (item (filter #'(lambda (item) (null (item-rhs-suc item))) (aref (parser-states parser) n)))
;; 	(let ((ps (rev-traverse parser (list n) (item-rhs-pre item))))
;; 	  (when ps
;; 	    (push (cons (cons n (cons (item-lhs item) (item-rhs-pre item))) (mapcar #'(lambda (p) (cons p (item-lhs item))) ps)) result)))))
;;     result))

;; (defun lookahead-set (cg parser)
;;   (let ((follows (follow-set cg parser))
;; 	(rel (rel-lookback parser))
;; 	(result nil))
;;     (dolist (lb rel result)
;;       (push (cons (car lb)
;; 		  (remove-duplicates
;; 		   (apply #'append (mapcar #'(lambda (transition) (cdr (assoceq transition follows))) (cdr lb)))
;; 		   :test #'equal)) result))))

;; (defun lalr1-parse-table (cg)
;;   (let* ((parser (lr0-parse-table cg))
;; 	 (lasets (lookahead-set cg parser))
;; 	 (state-array (make-array (parser-num parser) :initial-element nil)))
;;     (dotimes (n (parser-num parser))
;;       (setf (aref state-array n)
;; 	    (mapcar #'(lambda (item)
;; 			(destructuring-bind (lhs pre suc) item
;; 			  (cons item (and (null suc) (cdr (assoceq (cons n (cons lhs pre)) lasets))))))
;; 		    (aref (parser-states parser) n))))
;;     (make-parser (parser-num parser) state-array (parser-goto parser) nil)))



;; (defun lalr1-action-table (cg)
;;   (let* ((parser (lalr1-parse-table cg))
;; 	 (action-array (make-array (parser-num parser) :initial-element nil))
;; 	 (goto (parser-goto parser))
;; 	 ;; (action-table nil)
;; 	(error-info nil))
;;     (dotimes (n (parser-num parser))
;;       (setf (aref action-array n) (aref (parser-goto parser) n)))
;;     (dotimes (num (parser-num parser))
;;       (when (member (cons (list 0 (list (cg-start cg)) (list (cg-t-num cg))) nil) (aref (parser-states parser) num) :test #'equal)
;; 		(push (cons (cg-t-num cg) nil) (aref action-array num)))
;;       (dolist (lalr1-item (aref (parser-states parser) num))
;; 	(if (item-rhs-suc (car lalr1-item))
;; 	    (let ((a (first (item-rhs-suc (car lalr1-item)))))
;; 	      (when (and (cg-terminal-p cg a)
;; 			 (assoc a (aref goto num)))
;; 		(when (and (assoc a (aref action-array num))
;; 			   (not (member (assoceq a (aref goto num)) (aref action-array num) :test #'equal)))
;; 		  (pushnew (cons "duplicate action at shift" (cons num (assoc a (aref goto num)))) error-info :test #'equal))
;; 		(push (assoc a (aref goto num)) (aref action-array num))))
;; 	    (unless (= 0 (item-lhs (car lalr1-item)))
;; 	      (dolist (la (cdr lalr1-item))
;; 		(when (and (assoc la (aref action-array num))
;; 			   (not (member (cons la (cons (item-lhs (car lalr1-item))
;; 						       (item-rhs-pre (car lalr1-item)))) (aref action-array num) :test #'equal)))
;; 		  (pushnew (cons "duplicate action at reduce~%"
;; 				 (cons num (cons (cons (item-lhs (car lalr1-item))
;; 						       (item-rhs-pre (car lalr1-item)))
;; 						 (cdr (assoceq la (aref action-array num))))))
;; 			   error-info :test #'equal))
;; 		(push (cons la (cons (item-lhs (car lalr1-item))
;; 				     (item-rhs-pre (car lalr1-item))))
;; 		      (aref action-array num)))))))
;;     (or error-info
;; 	(progn
;; 	  (setf (parser-action parser) action-array)
;; 	  parser))))

  

;; ;; (defun gen-parse (table-gen eg tokens &key start eof (dump nil))
;; ;;   (let ((ptable (funcall table-gen eg :start start :eof eof))
;; ;; 	(stack (list 0)))
;; ;;     (setf tokens (append tokens (list eof)))
;; ;;     (loop
;; ;;       do (unless tokens (format t "error!") (return nil))
;; ;; 	 (let* ((acts (cdr (assoc (car stack) ptable)))
;; ;; 		(act (assoceq (car tokens) acts)))
;; ;; 	   (unless act (format t "error: [~a,~a]" stack tokens) (return nil))
;; ;; 	   (cond ((null (cdr act))
;; ;; 		  (when dump
;; ;; 		    (format t "~a~%" (append (reverse (remove-if #'numberp stack)) tokens)))
;; ;; 		  (format t "accept~%")
;; ;; 		  (return t))
;; ;; 		 ((listp (cdr act))
;; ;; 		  (when dump
;; ;; 		    (format t "~a~%" (append (reverse (remove-if #'numberp stack)) tokens)))
;; ;; 		  (let ((rule (cdr act)))
;; ;; 		    (dotimes (n (length (rule-rhs rule)))
;; ;; 		      (setf stack (cddr stack)))
;; ;; 		    (let ((next (cdr (assoceq (rule-lhs rule) (cdr (assoceq (car stack) ptable))))))
;; ;; 		      (push (rule-lhs rule) stack)
;; ;; 		      (push next stack))))
;; ;; 		    ;; (format t "~a~%" stack)
;; ;; 		 ((numberp (cdr act))
;; ;; 		  (push (pop tokens) stack)
;; ;; 		  (push (cdr act) stack))
;; ;; 		  ;; (format t "~a~%" stack)
;; ;; 		 (t (format t "irregular") (return nil)))))))  

;; ;; 
;; ;; by Dragon book
;; ;; 

;; (defun make-kernels (items)
;;   (filter #'(lambda (item) (or (= 0 (item-lhs item)) (item-rhs-pre item))) items))

;; (defun lr1-closure (cg lrset)
;;   (let ((tmplrset lrset)		; J = I
;; 	(changed t))
;;     (loop
;;       while changed
;;       do (setf changed nil)
;; 	 (dolist (lr1-item tmplrset)
;; 	   ;; (format t "~a~%" tmplrset)
;; 	   ;; (format t "~a~%" lr1-item)
;; 	   (let ((symb (first (item-rhs-suc (car lr1-item))))
;; 		 (suffix (rest (item-rhs-suc (car lr1-item)))))
;; 	     (when (and (numberp symb) (cg-non-terminal-p cg symb))
;; 	       ;; (format t "true~%")
;; 	       (dolist (rule (filter #'(lambda (rule) (= (rule-lhs rule) symb)) (cg-rules cg)))
;; 		 ;; (format t "{~a},~a~%" rule lr1-item)
;; 		 (let ((lookaheads (cdr lr1-item)))
;; 		   (if lookaheads
;; 		       (dolist (lookahead lookaheads)
;; 			 ;; (format t "[~{~a~}~a]~%" suffix lookahead)
;; 			 (dolist (b (cg-sequence-first cg (append suffix (list lookahead))))
;; 			   ;; (format t ">~a~%" b)
;; 			   (let ((lr1-newitem (cons (make-item (rule-lhs rule) '() (rule-rhs rule)) (list b))))
;; 			     ;; (format t ":: ~a~%" lr1-newitem)
;; 			     (unless (member lr1-newitem tmplrset :test #'equal)
;; 			       (push lr1-newitem tmplrset)
;; 			       (setf changed t)))))
;; 		       (dolist (b (cg-sequence-first cg suffix))
;; 			 ;; (format t ">~a~%" b)
;; 			 (let ((lr1-newitem (cons (list (rule-lhs rule) '() (rule-rhs rule)) (list b))))
;; 			   ;; (format t ":: ~a~%" lr1-newitem)
;; 			   (unless (member lr1-newitem tmplrset :test #'equal)
;; 			     (push lr1-newitem tmplrset)
;; 			     (setf changed t))))
;; 		       )))))))
;;     tmplrset))

;; (defun lr1-goto (cg lrset symb)
;;   (let ((items (filter
;; 		#'(lambda (lr1-item) (and (item-rhs-suc (car lr1-item)) (= symb (first (item-rhs-suc (car lr1-item))))))
;; 		lrset)))
;;   (lr1-closure cg (mapcar 
;; 		    #'(lambda (lr1-item)
;; 			(cons
;; 			 (list (item-lhs (car lr1-item))
;; 			       (cons (first (item-rhs-suc (car lr1-item))) (item-rhs-pre (car lr1-item)))
;; 			       (rest (item-rhs-suc (car lr1-item))))
;; 			 (cdr lr1-item)))
;; 		    items))))

;; (defun determine-lookaheads
;;     (cg kernels num symbol goto ht-from ht-spon pr-symbol)
;;   ;; (format t "[~a,~a,~a]~%" kernels num symbol)
;;   (let ((result nil))
;;     (dolist (item kernels result)
;;       (let ((j (lr1-closure cg (list (cons item (list pr-symbol)))))
;; 	    (tmp nil))
;; 	;; (format t "~a~%" j)
;; 	(dolist (lr1-item j)
;; 	  (when (and (item-rhs-suc (car lr1-item)) (= symbol (first (item-rhs-suc (car lr1-item)))))
;; 	    (let ((to-num (cdr (assoc symbol (cdr (assoceq num goto)))))
;; 		  (to-item (shift-item (car lr1-item))))
;; 	      (if (member pr-symbol (cdr lr1-item))
;; 		  (progn
;; 		    (push (list 'propagate to-num to-item) tmp)
;; 		    (push (cons num item)
;; 			  (gethash (cons to-num to-item) ht-from)))
;; 		  (progn
;; 		    (push (list 'spontaneously (cons num item) to-num to-item (cdr lr1-item)) tmp)
;; 		    (setf
;; 		     (gethash (cons to-num to-item) ht-spon)
;; 		     (union (cdr lr1-item) (gethash (cons to-num to-item) ht-spon))))))))
;; 	(when tmp (push tmp result))
;; 	))))

;; (defun make-lalr1-items (cg)
;;   (let* (
;; 	 ;; step 1 and 2
;; 	 (all-items (lr0-parse-table cg))
;; 	 ;; step 3
;; 	 (all-kernels 
;; 	   (mapcar #'(lambda (x)
;; 		       (cons (make-kernels (car x)) (cdr x))) ; magic-number: 0
;; 		   (car all-items)))
;; 	 (result nil)
;; 	 (all-lalr1-kernels nil)
;; 	 ;; (not-in-symbol (gensym))
;; 	 (ht-from (make-hash-table :test #'equal))
;; 	 (ht-spon (make-hash-table :test #'equal)))
;;     ;; step 4
;;     (setf (gethash
;;     	   (cons 0 (list 0 () (list (cg-start cg) (cg-t-num cg))))
;;     	   ht-spon)
;; 	  nil)
;;     (dolist (kernels-and-num all-kernels)
;;       (let ((kernels (car kernels-and-num))
;; 	    (num (cdr kernels-and-num))
;; 	    (tmp nil))
;; 	(dotimes (symb (cg-t-num cg))
;; 	  (let ((dl (determine-lookaheads cg kernels num symb (cdr all-items) ht-from ht-spon (+ (cg-t-num cg) 1))))
;; 	    (when dl (push dl tmp))))
;; 	(when tmp (push (cons kernels tmp) result))))
;;     ;; (format t "~a~%" result)
;;     ;; step 5.
;;     (let ((ht-lookaheads (make-hash-table :test #'equal)))
;;       ;; spontaneously lookaheads
;;       (dolist (kernels-and-num all-kernels)
;; 	(let ((kernels (car kernels-and-num))
;; 	      (num (cdr kernels-and-num)))
;; 	  (dolist (kern kernels)
;; 	    (setf (gethash (cons num kern) ht-lookaheads)
;; 		  (gethash (cons num kern) ht-spon)))))
;;       ;; lookaheads' propagation
;;       (let ((changed t))
;; 	(loop
;; 	  while changed
;; 	  do (setf changed nil)
;; 	     (dolist (kernels-and-num all-kernels)
;; 	       (let* ((kernels (car kernels-and-num))
;; 		      (num (cdr kernels-and-num)))
;; 		 (dolist (kernel kernels)
;; 		   (let ((old (copy-list (gethash (cons num kernel) ht-lookaheads))))
;; 		     (dolist (from (remove-if #'(lambda (x) (equal (cons num kernel) x)) (gethash (cons num kernel) ht-from)))
;; 		       (setf (gethash (cons num kernel) ht-lookaheads)
;; 			     (union (gethash (cons num kernel) ht-lookaheads)
;; 				    (gethash from ht-lookaheads)
;; 				    :test #'equal)))
;; 		     (unless (set-eq old (gethash (cons num kernel) ht-lookaheads))
;; 		       (setf changed t))))))))
;;      ;; make lalr1-kernels
;;       ;; (format t "******~%")
;;       ;; (format t "~a~%" all-kernels)
;;       ;; (format t "******~%")
;;       (dolist (kernels-and-num all-kernels all-lalr1-kernels)
;; 	(let ((kernels (car kernels-and-num))
;; 	      (num (cdr kernels-and-num))
;; 	      (lalr1-kernels nil))
;; 	  (dolist (kernel kernels)
;; 	    (push (cons kernel (gethash (cons num kernel) ht-lookaheads)) lalr1-kernels))
;; 	  (push (cons lalr1-kernels num) all-lalr1-kernels)))
;;       ;; step 6. from kernel to state
;;       ;; (format t "~a~%" all-lalr1-kernels)
;;       (let ((l (mapcar
;; 		#'(lambda (x)
;; 		    (cons 
;; 		     (lalr1-state-compress (lr1-closure cg (car x)))
;; 		     (cdr x)))
;; 		all-lalr1-kernels)))
;; 	(cons l (cdr all-items))))))

;; (defun lalr1-state-compress (state)
;;   (sort
;;    (foldl '()
;; 	  #'(lambda (items item)
;; 	      (if items
;; 		  (let ((sep-ls (separate
;; 				 #'(lambda (x) (equal (car item) (car x)))
;; 				 items)))
;; 		    (cons (cons (car item)
;; 				(union (cdr item) (cdaar sep-ls)))
;; 			  (cdr sep-ls)))
;; 		  (list item)))
;; 	  state)
;;    #'(lambda (x y) (< (caar x) (caar y))))
;;   )

;; (defun separate (predicate list &key (key #'identity))
;;   (labels ((f (x y)
;; 	     (if (funcall predicate (funcall key y))
;; 		 (cons (cons y (car x)) (cdr x))
;; 		 (cons (car x) (cons y (cdr x))))))
;;     (foldl (cons () ()) #'f list)))



;; ;; 
;; ;; checker
;; (defun lalr-checker (grammar start eof)
;;   (let ((l nil)
;; 	(r nil))
;;     (loop for x in (mapcar #'(lambda (items) (mapcar #'(lambda (item) (if (item-rhs-suc (car item)) (cons (car item) nil) item)) items)) (mapcar #'car (sort (car (make-lalr1-items (enrich-grammar grammar) :start start :eof eof)) #'< :key #'cdr)))
;; 	  for y in (mapcar #'car (sort (car (lalr1-parse-table (enrich-grammar grammar) :start start :eof eof)) #'< :key #'cdr))
;; 	  do (destructuring-bind (xl . xr) (separate #'(lambda (x) (cdr x)) x)
;; 	       (destructuring-bind (yl . yr) (separate #'(lambda (x) (cdr x)) y)
;; 		 (push (cons xl yl) l) (push (cons xr yr) r))))
;;     (cons
;;      (mapcar #'(lambda (x) (cons (equal (caar x) (cadr x)) (set-eq (cdar x) (cddr x))))
;; 		    (mapcar #'(lambda (p) (cons (caar p) (cadr p))) l))
;; 	    (mapcar #'(lambda (p) (set-eq (car p) (cdr p))) r))))






;; ;; print
;; (defun print-goto (goto-table stream)
;;   (mapc #'(lambda (x)
;; 	    (let ((num (car x)) (to (cdr x)))
;; 	      (dolist (y to)
;; 		(format stream "~a --~a-> ~a~%" num (car y) (cdr y))))) goto-table) nil)


;; (defun print-lalr1-item (item sep stream)
;;   (let ((lr-item (car item))
;; 	(lasets (cdr item)))
;;     (format stream "[~a\\ -\\>\\ ~{~a\\ ~}~a~{\\ ~a~}\\ ,\\ ~{~a~^\\~}]"
;; 	    (item-lhs lr-item) (item-rhs-pre lr-item) sep (item-rhs-suc lr-item) lasets)))

;; (defun print-lalr1-parse-table (pt sep stream)
;;   (format stream "digraph lalr1_automaton {~%  graph [rankdir = LR];~%")
;;   (dolist (state-num (car pt))
;;     (format stream
;; 	    "  ~a [shape=record, label=\"{~a|{~{~a\\l~}}}\"];~%"
;; 	    (cdr state-num) (cdr state-num) (mapcar #'(lambda (item) (print-lalr1-item item sep nil)) (car state-num))))
;;   (dolist (row (cdr pt))
;;     (dolist (to (cdr row))
;;       (format stream "  ~a -> ~a [label=\"~a\"];~%" (car row) (cdr to) (car to))))
;;   (format stream "}~%"))

;; (defun dot-lalr1-automaton (grammar fname &key start eof sep)
;;   (with-open-file (s (concatenate 'string fname ".dot")
;; 		     :direction :output
;; 		     :if-exists :rename-and-delete :if-does-not-exist :create
;; 		     :external-format :utf-8)
;;     (let ((pt (lalr1-parse-table (enrich-grammar grammar) :start start :eof eof)))
;;       (print-lalr1-parse-table pt sep s))))




;; grammar samples
(defparameter *g1*
  (make-grammar "E"
             '(("E" "E" "+" "T") ("E" "T") ("T" "T" "*" "F") ("T" "F")
	       ("F" "(" "E" ")") ("F" "id")))) 
(defparameter *g2*
  (make-grammar "S" '(("S" "id") ("S" "S" "," "id")))) 
(defparameter *g3*
  (make-grammar "S" '(("S" "A") ("S" "S" "A")))) 
(defparameter *g4*
  (make-grammar "S" '(("S" "A") ("S" "A" "S")))) 
(defparameter *g5*
  (make-grammar "S" '(("S" "int" "L") ("L" "id") ("L" "L" "," "id")))) 
(defparameter *g6*
  (make-grammar "S"
             '(("S" "L" "=" "R") ("S" "R") ("L" "*" "R") ("L" "id")
	       ("R" "L")))) 
(defparameter *g7*
  (make-grammar "S" '(("S" "C" "C") ("C" "B" "C") ("C" "D")))) 
(defparameter *g8*
  (make-grammar "S"
             '(("S" "L" "=" "E") ("L" "id") ("L" "R" "^" "id")
              ("E" "E" "+" "R") ("E" "R") ("E" "@" "L") ("R" "id")))) 
(defparameter *G9*
  (make-grammar "A" '(("A" "b" "B") ("B" "c" "C") ("C" "d" "A") ("A" "a"))))
(defparameter *G10*
  (make-grammar "A" '(("A" "B" "C" "D" "A") ("B") ("C") ("D") ("A" "X")))) 
(defparameter *g11*
  (make-grammar "S" '(("S" "A" "B") ("A") ("B") ("A" "x"))))


(defparameter *cbnf*
  (make-grammar "translation_unit"
	     '(("translation_unit" "external_decl")
	       ("translation_unit" "translation_unit" "external_decl")
	       ("external_decl" "function_definition")
	       ("external_decl" "decl")
	       ("function_definition" "decl_specs" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "decl_specs" "declarator" "compound_stat")
	       ("function_definition" "declarator" "compound_stat")
	       ("decl" "decl_specs" "init_declarator_list" "';'")
	       ("decl" "decl_specs" "';'")
	       ("decl_list" "decl")
	       ("decl_list" "decl_list" "decl")
	       ("decl_specs" "storage_class_spec" "decl_specs")
	       ("decl_specs" "storage_class_spec")
	       ("decl_specs" "type_spec" "decl_specs")
	       ("decl_specs" "type_spec")
	       ("decl_specs" "type_qualifier" "decl_specs")
	       ("decl_specs" "type_qualifier")
	       ("storage_class_spec" "'auto'")
	       ("storage_class_spec" "'register'")
	       ("storage_class_spec" "'static'")
	       ("storage_class_spec" "'extern'")
	       ("storage_class_spec" "'typedef'")
	       ("type_spec" "'void'")
	       ("type_spec" "'char'")
	       ("type_spec" "'short'")
	       ("type_spec" "'int'")
	       ("type_spec" "'long'")
	       ("type_spec" "'float'")
	       ("type_spec" "'double'")
	       ("type_spec" "'signed'")
	       ("type_spec" "'unsigned'")
	       ("type_spec" "struct_or_union_spec")
	       ("type_spec" "enum_spec")
	       ("type_spec" "typedef_name")
	       ("type_qualifier" "'const'")
	       ("type_qualifier" "'volatile'")
	       ("struct_or_union_spec" "struct_or_union" "id" "'\{'" "struct_decl_list" "'\}'")
	       ("struct_or_union_spec" "struct_or_union" "'\{'" "struct_decl_list" "'\}'")
	       ("struct_or_union_spec" "struct_or_union" "id")
	       ("struct_or_union" "'struct'")
	       ("struct_or_union" "'union'")
	       ("struct_decl_list" "struct_decl")
	       ("struct_decl_list" "struct_decl_list" "struct_decl")
	       ("init_declarator_list" "init_declarator")
	       ("init_declarator_list" "init_declarator_list" "','" "init_declarator")
	       ("init_declarator" "declarator")
	       ("init_declarator" "declarator" "'='" "initializer")
	       ("struct_decl" "spec_qualifier_list" "struct_declarator_list" "';'")
	       ("spec_qualifier_list" "type_spec" "spec_qualifier_list")
	       ("spec_qualifier_list" "type_spec")
	       ("spec_qualifier_list" "type_qualifier" "spec_qualifier_list")
	       ("spec_qualifier_list" "type_qualifier")
	       ("struct_declarator_list" "struct_declarator")
	       ("struct_declarator_list" "struct_declarator_list" "','" "struct_declarator")
	       ("struct_declarator" "declarator")
	       ("struct_declarator" "declarator" "':'" "const_exp")
	       ("struct_declarator" "':'" "const_exp")
	       ("enum_spec" "'enum'" "id" "'\{'" "enumerator_list" "'\}'")
	       ("enum_spec" "'enum'" "'\{'" "enumerator_list" "'\}'")
	       ("enum_spec" "'enum'" "id")
	       ("enumerator_list" "enumerator")
	       ("enumerator_list" "enumerator_list" "','" "enumerator")
	       ("enumerator" "id")
	       ("enumerator" "id" "'='" "const_exp")
	       ("declarator" "pointer" "direct_declarator")
	       ("declarator" "direct_declarator")
	       ("direct_declarator" "id")
	       ("direct_declarator" "'('" "declarator" "')'")
	       ("direct_declarator" "direct_declarator" "'['" "const_exp" "']'")
	       ("direct_declarator" "direct_declarator" "'['" "']'")
	       ("direct_declarator" "direct_declarator" "'('" "param_type_list" "')'")
	       ("direct_declarator" "direct_declarator" "'('" "id_list" "')'")
	       ("direct_declarator" "direct_declarator" "'('" "')'")
	       ("pointer" "'*'" "type_qualifier_list")
	       ("pointer" "'*'")
	       ("pointer" "'*'" "type_qualifier_list" "pointer")
	       ("pointer" "'*'" "pointer")
	       ("type_qualifier_list" "type_qualifier")
	       ("type_qualifier_list" "type_qualifier_list" "type_qualifier")
	       ("param_type_list" "param_list")
	       ("param_type_list" "param_list" "','" "'...'")
	       ("param_list" "param_decl")
	       ("param_list" "param_list" "','" "param_decl")
	       ("param_decl" "decl_specs" "declarator")
	       ("param_decl" "decl_specs" "abstract_declarator")
	       ("param_decl" "decl_specs")
	       ("id_list" "id")
	       ("id_list" "id_list" "','" "id")
	       ("initializer" "assignment_exp")
	       ("initializer" "'\{'" "initializer_list" "'\}'")
	       ("initializer" "'\{'" "initializer_list" "','" "'\}'")
	       ("initializer_list" "initializer")
	       ("initializer_list" "initializer_list" "','" "initializer")
	       ("type_name" "spec_qualifier_list" "abstract_declarator")
	       ("type_name" "spec_qualifier_list")
	       ("abstract_declarator" "pointer")
	       ("abstract_declarator" "pointer" "direct_abstract_declarator")
	       ("abstract_declarator" "direct_abstract_declarator")
	       ("direct_abstract_declarator" "'('" "abstract_declarator" "')'")
	       ("direct_abstract_declarator" "direct_abstract_declarator" "'['" "const_exp" "']'")
	       ("direct_abstract_declarator" "'['" "const_exp" "']'")
	       ("direct_abstract_declarator" "direct_abstract_declarator" "'['" "']'")
	       ("direct_abstract_declarator" "'['" "']'")
	       ("direct_abstract_declarator" "direct_abstract_declarator" "'('" "param_type_list" "')'")
	       ("direct_abstract_declarator" "'('" "param_type_list" "')'")
	       ("direct_abstract_declarator" "direct_abstract_declarator" "'('" "')'")
	       ("direct_abstract_declarator" "'('" "')'")
	       ("typedef_name" "id")
	       ("stat" "labeled_stat")
	       ("stat" "exp_stat")
	       ("stat" "compound_stat")
	       ("stat" "selection_stat")
	       ("stat" "iteration_stat")
	       ("stat" "jump_stat")
	       ("labeled_stat" "id" "':'" "stat")
	       ("labeled_stat" "'case'" "const_exp" "':'" "stat")
	       ("labeled_stat" "'default'" "':'" "stat")
	       ("exp_stat" "exp" "';'")
	       ("exp_stat" "';'")
	       ("compound_stat" "'\{'" "decl_list" "stat_list" "'\}'")
	       ("compound_stat" "'\{'" "stat_list" "'\}'")
	       ("compound_stat" "'\{'" "decl_list" "'\}'")
	       ("compound_stat" "'\{'" "'\}'")
	       ("stat_list" "stat")
	       ("stat_list" "stat_list" "stat")
	       ("selection_stat" "'if'" "'('" "exp" "')'" "stat")
	       ("selection_stat" "'if'" "'('" "exp" "')'" "stat" "'else'" "stat")
	       ("selection_stat" "'switch'" "'('" "exp" "')'" "stat")
	       ("iteration_stat" "'while'" "'('" "exp" "')'" "stat")
	       ("iteration_stat" "'do'" "stat" "'while'" "'('" "exp" "')'" "';'")
	       ("iteration_stat" "'for'" "'('" "exp" "';'" "exp" "';'" "exp" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "exp" "';'" "exp" "';'" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "exp" "';'" "';'" "exp" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "exp" "';'" "';'" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "';'" "exp" "';'" "exp" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "';'" "exp" "';'" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "';'" "';'" "exp" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "';'" "';'" "')'" "stat")
	       ("jump_stat" "'goto'" "id" "';'")
	       ("jump_stat" "'continue'" "';'")
	       ("jump_stat" "'break'" "';'")
	       ("jump_stat" "'return'" "exp" "';'")
	       ("jump_stat" "'return'" "';'")
	       ("exp" "assignment_exp")
	       ("exp" "exp" "','" "assignment_exp")
	       ("assignment_exp" "conditional_exp")
	       ("assignment_exp" "unary_exp" "assignment_operator" "assignment_exp")
	       ("assignment_operator" "'='")
	       ("assignment_operator" "'*='")
	       ("assignment_operator" "'/='")
	       ("assignment_operator" "'%='")
	       ("assignment_operator" "'+='")
	       ("assignment_operator" "'-='")
	       ("assignment_operator" "'\<\<='")
	       ("assignment_operator" "'\>\>='")
	       ("assignment_operator" "'&='")
	       ("assignment_operator" "'^='")
	       ("assignment_operator" "'|='")
	       ("conditional_exp" "logical_or_exp")
	       ("conditional_exp" "logical_or_exp" "'?'" "exp" "':'" "conditional_exp")
	       ("const_exp" "conditional_exp")
	       ("logical_or_exp" "logical_and_exp")
	       ("logical_or_exp" "logical_or_exp" "'||'" "logical_and_exp")
	       ("logical_and_exp" "inclusive_or_exp")
	       ("logical_and_exp" "logical_and_exp" "'&&'" "inclusive_or_exp")
	       ("inclusive_or_exp" "exclusive_or_exp")
	       ("inclusive_or_exp" "inclusive_or_exp" "'|'" "exclusive_or_exp")
	       ("exclusive_or_exp" "and_exp")
	       ("exclusive_or_exp" "exclusive_or_exp" "'^'" "and_exp")
	       ("and_exp" "equality_exp")
	       ("and_exp" "and_exp" "'&'" "equality_exp")
	       ("equality_exp" "relational_exp")
	       ("equality_exp" "equality_exp" "'=='" "relational_exp")
	       ("equality_exp" "equality_exp" "'!='" "relational_exp")
	       ("relational_exp" "shift_expression")
	       ("relational_exp" "relational_exp" "'\<'" "shift_expression")
	       ("relational_exp" "relational_exp" "'\>'" "shift_expression")
	       ("relational_exp" "relational_exp" "'\<='" "shift_expression")
	       ("relational_exp" "relational_exp" "'\>='" "shift_expression")
	       ("shift_expression" "additive_exp")
	       ("shift_expression" "shift_expression" "'\<\<'" "additive_exp")
	       ("shift_expression" "shift_expression" "'\>\>'" "additive_exp")
	       ("additive_exp" "mult_exp")
	       ("additive_exp" "additive_exp" "'+'" "mult_exp")
	       ("additive_exp" "additive_exp" "'-'" "mult_exp")
	       ("mult_exp" "cast_exp")
	       ("mult_exp" "mult_exp" "'*'" "cast_exp")
	       ("mult_exp" "mult_exp" "'/'" "cast_exp")
	       ("mult_exp" "mult_exp" "'%'" "cast_exp")
	       ("cast_exp" "unary_exp")
	       ("cast_exp" "'('" "type_name" "')'" "cast_exp")
	       ("unary_exp" "postfix_exp")
	       ("unary_exp" "'++'" "unary_exp")
	       ("unary_exp" "'--'" "unary_exp")
	       ("unary_exp" "unary_operator" "cast_exp")
	       ("unary_exp" "'sizeof'" "unary_exp")
	       ("unary_exp" "'sizeof'" "'('" "type_name" "')'")
	       ("unary_operator" "'&'")
	       ("unary_operator" "'*'")
	       ("unary_operator" "'+'")
	       ("unary_operator" "'-'")
	       ("unary_operator" "'~'")
	       ("unary_operator" "'!'")
	       ("postfix_exp" "primary_exp")
	       ("postfix_exp" "postfix_exp" "'['" "exp" "']'")
	       ("postfix_exp" "postfix_exp" "'('" "argument_exp_list" "')'")
	       ("postfix_exp" "postfix_exp" "'('" "')'")
	       ("postfix_exp" "postfix_exp" "'.'" "id")
	       ("postfix_exp" "postfix_exp" "'-\>'" "id")
	       ("postfix_exp" "postfix_exp" "'++'")
	       ("postfix_exp" "postfix_exp" "'--'")
	       ("primary_exp" "id")
	       ("primary_exp" "const")
	       ("primary_exp" "string")
	       ("primary_exp" "'('" "exp" "')'")
	       ("argument_exp_list" "assignment_exp")
	       ("argument_exp_list" "argument_exp_list" "','" "assignment_exp")
	       ("const" "int_const")
	       ("const" "char_const")
	       ("const" "float_const")
	       ("const" "enumeration_const")
	       )))

(defparameter *cbnf-min*
  (make-grammar "translation_unit"
	     '(("translation_unit" "external_decl")
	       ("translation_unit" "translation_unit" "external_decl")
	       ("external_decl" "function_definition")
	       ("external_decl" "decl")
	       ("function_definition" "decl_specs" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "decl_specs" "declarator" "compound_stat")
	       ("function_definition" "declarator" "compound_stat")
	       ("decl" "decl_specs" "init_declarator_list" "';'")
	       ("decl" "decl_specs" "';'")
	       ("decl_list" "decl")
	       ("decl_list" "decl_list" "decl")
	       ("storage_class_spec" "'auto'")
	       ("storage_class_spec" "'register'")
	       ("storage_class_spec" "'static'")
	       ("storage_class_spec" "'extern'")
	       ("storage_class_spec" "'typedef'")
	       ("type_qualifier" "'const'")
	       ("type_qualifier" "'volatile'")
	       ("struct_or_union_spec" "struct_or_union" "id" "'\{'" "struct_decl_list" "'\}'")
	       ("struct_or_union_spec" "struct_or_union" "'\{'" "struct_decl_list" "'\}'")
	       ("struct_or_union_spec" "struct_or_union" "id")
	       ("struct_or_union" "'struct'")
	       ("struct_or_union" "'union'")
	       ("struct_decl_list" "struct_decl")
	       ("struct_decl_list" "struct_decl_list" "struct_decl")
	       ("init_declarator_list" "init_declarator")
	       ("init_declarator_list" "init_declarator_list" "','" "init_declarator")
	       ("init_declarator" "declarator")
	       ("init_declarator" "declarator" "'='" "initializer")
	       ("struct_decl" "spec_qualifier_list" "struct_declarator_list" "';'")
	       ("spec_qualifier_list" "type_spec" "spec_qualifier_list")
	       ("spec_qualifier_list" "type_spec")
	       ("spec_qualifier_list" "type_qualifier" "spec_qualifier_list")
	       ("spec_qualifier_list" "type_qualifier")
	       ("struct_declarator_list" "struct_declarator")
	       ("struct_declarator_list" "struct_declarator_list" "','" "struct_declarator")
	       ("struct_declarator" "declarator")
	       ("struct_declarator" "declarator" "':'" "const_exp")
	       ("struct_declarator" "':'" "const_exp")
	       ("enum_spec" "'enum'" "id" "'\{'" "enumerator_list" "'\}'")
	       ("enum_spec" "'enum'" "'\{'" "enumerator_list" "'\}'")
	       ("enum_spec" "'enum'" "id")
	       ("enumerator_list" "enumerator")
	       ("enumerator_list" "enumerator_list" "','" "enumerator")
	       ("enumerator" "id")
	       ("enumerator" "id" "'='" "const_exp")
	       ("declarator" "pointer" "direct_declarator")
	       ("declarator" "direct_declarator")
	       ("pointer" "'*'" "type_qualifier_list")
	       ("pointer" "'*'")
	       ("pointer" "'*'" "type_qualifier_list" "pointer")
	       ("pointer" "'*'" "pointer")
	       ("type_qualifier_list" "type_qualifier")
	       ("type_qualifier_list" "type_qualifier_list" "type_qualifier")
	       ("param_type_list" "param_list")
	       ("param_type_list" "param_list" "','" "'...'")
	       ("param_list" "param_decl")
	       ("param_list" "param_list" "','" "param_decl")
	       ("param_decl" "decl_specs" "declarator")
	       ("param_decl" "decl_specs" "abstract_declarator")
	       ("param_decl" "decl_specs")
	       ("id_list" "id")
	       ("id_list" "id_list" "','" "id")
	       ("initializer_list" "initializer")
	       ("initializer_list" "initializer_list" "','" "initializer")
	       ("type_name" "spec_qualifier_list" "abstract_declarator")
	       ("type_name" "spec_qualifier_list")
	       ("abstract_declarator" "pointer")
	       ("abstract_declarator" "pointer" "direct_abstract_declarator")
	       ("abstract_declarator" "direct_abstract_declarator")
	       ("typedef_name" "id")
	       ("stat" "labeled_stat")
	       ("stat" "exp_stat")
	       ("stat" "compound_stat")
	       ("stat" "selection_stat")
	       ("stat" "iteration_stat")
	       ("stat" "jump_stat")
	       ("labeled_stat" "id" "':'" "stat")
	       ("labeled_stat" "'case'" "const_exp" "':'" "stat")
	       ("labeled_stat" "'default'" "':'" "stat")
	       ("exp_stat" "exp" "';'")
	       ("exp_stat" "';'")
	       ("compound_stat" "'\{'" "decl_list" "stat_list" "'\}'")
	       ("compound_stat" "'\{'" "stat_list" "'\}'")
	       ("compound_stat" "'\{'" "decl_list" "'\}'")
	       ("compound_stat" "'\{'" "'\}'")
	       ("stat_list" "stat")
	       ("stat_list" "stat_list" "stat")
	       ("jump_stat" "'goto'" "id" "';'")
	       ("jump_stat" "'continue'" "';'")
	       ("jump_stat" "'break'" "';'")
	       ("jump_stat" "'return'" "exp" "';'")
	       ("jump_stat" "'return'" "';'")
	       ("exp" "assignment_exp")
	       ("exp" "exp" "','" "assignment_exp")
	       ("assignment_exp" "conditional_exp")
	       ("assignment_exp" "unary_exp" "assignment_operator" "assignment_exp")
	       ("conditional_exp" "logical_or_exp")
	       ("conditional_exp" "logical_or_exp" "'?'" "exp" "':'" "conditional_exp")
	       ("const_exp" "conditional_exp")
	       ("equality_exp" "relational_exp")
	       ("equality_exp" "equality_exp" "'=='" "relational_exp")
	       ("equality_exp" "equality_exp" "'!='" "relational_exp")
	       ("shift_expression" "additive_exp")
	       ("shift_expression" "shift_expression" "'\<\<'" "additive_exp")
	       ("shift_expression" "shift_expression" "'\>\>'" "additive_exp")
	       ("additive_exp" "mult_exp")
	       ("additive_exp" "additive_exp" "'+'" "mult_exp")
	       ("additive_exp" "additive_exp" "'-'" "mult_exp")
	       ("mult_exp" "cast_exp")
	       ("mult_exp" "mult_exp" "'*'" "cast_exp")
	       ("mult_exp" "mult_exp" "'/'" "cast_exp")
	       ("mult_exp" "mult_exp" "'%'" "cast_exp")
	       ("cast_exp" "unary_exp")
	       ("cast_exp" "'('" "type_name" "')'" "cast_exp")
	       ("argument_exp_list" "assignment_exp")
	       ("argument_exp_list" "argument_exp_list" "','" "assignment_exp")
	       )))

(defparameter *cbnf-petit*
  (make-grammar "translation_unit"
	     '(("translation_unit" "external_decl")
	       ("translation_unit" "translation_unit" "external_decl")
	       ("external_decl" "function_definition")
	       ("external_decl" "decl")
	       ("function_definition" "decl_specs" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "decl_specs" "declarator" "compound_stat")
	       ("function_definition" "declarator" "compound_stat")
	       ("decl" "decl_specs" "init_declarator_list" "';'")
	       ("decl" "decl_specs" "';'")
	       ("init_declarator_list" "init_declarator")
	       ("init_declarator_list" "init_declarator_list" "','" "init_declarator")
	       ("init_declarator" "declarator")
	       ("init_declarator" "declarator" "'='" "initializer")
	       ("struct_decl" "spec_qualifier_list" "struct_declarator_list" "';'")
	       ("struct_declarator_list" "struct_declarator")
	       ("struct_declarator_list" "struct_declarator_list" "','" "struct_declarator")
	       ("struct_declarator" "declarator")
	       ("struct_declarator" "declarator" "':'" "const_exp")
	       ("struct_declarator" "':'" "const_exp")
	       ("declarator" "pointer" "direct_declarator")
	       ("declarator" "direct_declarator")
	       ("pointer" "'*'" "type_qualifier_list")
	       ("pointer" "'*'")
	       ("pointer" "'*'" "type_qualifier_list" "pointer")
	       ("pointer" "'*'" "pointer")
	       ("type_qualifier_list" "type_qualifier")
	       ("type_qualifier_list" "type_qualifier_list" "type_qualifier")
	       ("param_type_list" "param_list")
	       ("param_type_list" "param_list" "','" "'...'")
	       ("param_list" "param_decl")
	       ("param_list" "param_list" "','" "param_decl")
	       ("param_decl" "decl_specs" "declarator")
	       ("param_decl" "decl_specs" "abstract_declarator")
	       ("param_decl" "decl_specs")
	       ("id_list" "id")
	       ("id_list" "id_list" "','" "id")
	       ("initializer_list" "initializer")
	       ("initializer_list" "initializer_list" "','" "initializer")
	       ("type_name" "spec_qualifier_list" "abstract_declarator")
	       ("type_name" "spec_qualifier_list")
	       ("typedef_name" "id")
	       ("labeled_stat" "id" "':'" "stat")
	       ("labeled_stat" "'case'" "const_exp" "':'" "stat")
	       ("labeled_stat" "'default'" "':'" "stat")
	       )))



(defparameter *cbnf-alist*
  '(("const" ("enumeration_const") ("float_const") ("char_const")
     ("int_const"))
    ("argument_exp_list" ("argument_exp_list" "','" "assignment_exp")
     ("assignment_exp"))
    ("primary_exp" ("'('" "exp" "')'") ("string") ("const") ("id"))
    ("postfix_exp" ("postfix_exp" "'--'") ("postfix_exp" "'++'")
     ("postfix_exp" "'->'" "id") ("postfix_exp" "'.'" "id")
     ("postfix_exp" "'('" "')'")
     ("postfix_exp" "'('" "argument_exp_list" "')'")
     ("postfix_exp" "'['" "exp" "']'") ("primary_exp"))
    ("unary_operator" ("'!'") ("'~'") ("'-'") ("'+'") ("'*'") ("'&'"))
    ("unary_exp" ("'sizeof'" "'('" "type_name" "')'")
     ("'sizeof'" "unary_exp") ("unary_operator" "cast_exp")
     ("'--'" "unary_exp") ("'++'" "unary_exp") ("postfix_exp"))
    ("cast_exp" ("'('" "type_name" "')'" "cast_exp") ("unary_exp"))
    ("mult_exp" ("mult_exp" "'%'" "cast_exp")
     ("mult_exp" "'/'" "cast_exp") ("mult_exp" "'*'" "cast_exp")
     ("cast_exp"))
    ("additive_exp" ("additive_exp" "'-'" "mult_exp")
     ("additive_exp" "'+'" "mult_exp") ("mult_exp"))
    ("shift_expression" ("shift_expression" "'>>'" "additive_exp")
     ("shift_expression" "'<<'" "additive_exp") ("additive_exp"))
    ("relational_exp" ("relational_exp" "'>='" "shift_expression")
     ("relational_exp" "'<='" "shift_expression")
     ("relational_exp" "'>'" "shift_expression")
     ("relational_exp" "'<'" "shift_expression") ("shift_expression"))
    ("equality_exp" ("equality_exp" "'!='" "relational_exp")
     ("equality_exp" "'=='" "relational_exp") ("relational_exp"))
    ("and_exp" ("and_exp" "'&'" "equality_exp") ("equality_exp"))
    ("exclusive_or_exp" ("exclusive_or_exp" "'^'" "and_exp") ("and_exp"))
    ("inclusive_or_exp" ("inclusive_or_exp" "'|'" "exclusive_or_exp")
     ("exclusive_or_exp"))
    ("logical_and_exp" ("logical_and_exp" "'&&'" "inclusive_or_exp")
     ("inclusive_or_exp"))
    ("logical_or_exp" ("logical_or_exp" "'||'" "logical_and_exp")
     ("logical_and_exp"))
    ("const_exp" ("conditional_exp"))
    ("conditional_exp"
     ("logical_or_exp" "'?'" "exp" "':'" "conditional_exp")
     ("logical_or_exp"))
    ("assignment_operator" ("'|='") ("'^='") ("'&='") ("'>>='") ("'<<='")
     ("'-='") ("'+='") ("'%='") ("'/='") ("'*='") ("'='"))
    ("assignment_exp" ("unary_exp" "assignment_operator" "assignment_exp")
     ("conditional_exp"))
    ("exp" ("exp" "','" "assignment_exp") ("assignment_exp"))
    ("jump_stat" ("'return'" "';'") ("'return'" "exp" "';'")
     ("'break'" "';'") ("'continue'" "';'") ("'goto'" "id" "';'"))
    ("iteration_stat" ("'for'" "'('" "';'" "';'" "')'" "stat")
     ("'for'" "'('" "';'" "';'" "exp" "')'" "stat")
     ("'for'" "'('" "';'" "exp" "';'" "')'" "stat")
     ("'for'" "'('" "';'" "exp" "';'" "exp" "')'" "stat")
     ("'for'" "'('" "exp" "';'" "';'" "')'" "stat")
     ("'for'" "'('" "exp" "';'" "';'" "exp" "')'" "stat")
     ("'for'" "'('" "exp" "';'" "exp" "';'" "')'" "stat")
     ("'for'" "'('" "exp" "';'" "exp" "';'" "exp" "')'" "stat")
     ("'do'" "stat" "'while'" "'('" "exp" "')'" "';'")
     ("'while'" "'('" "exp" "')'" "stat"))
    ("selection_stat" ("'switch'" "'('" "exp" "')'" "stat")
     ("'if'" "'('" "exp" "')'" "stat" "'else'" "stat")
     ("'if'" "'('" "exp" "')'" "stat"))
    ("stat_list" ("stat_list" "stat") ("stat"))
    ("compound_stat" ("'{'" "'}'") ("'{'" "decl_list" "'}'")
     ("'{'" "stat_list" "'}'") ("'{'" "decl_list" "stat_list" "'}'"))
    ("exp_stat" ("';'") ("exp" "';'"))
    ("labeled_stat" ("'default'" "':'" "stat")
     ("'case'" "const_exp" "':'" "stat") ("id" "':'" "stat"))
    ("stat" ("jump_stat") ("iteration_stat") ("selection_stat")
     ("compound_stat") ("exp_stat") ("labeled_stat"))
    ("typedef_name" ("id"))
    ("direct_abstract_declarator" ("'('" "')'")
     ("direct_abstract_declarator" "'('" "')'")
     ("'('" "param_type_list" "')'")
     ("direct_abstract_declarator" "'('" "param_type_list" "')'")
     ("'['" "']'") ("direct_abstract_declarator" "'['" "']'")
     ("'['" "const_exp" "']'")
     ("direct_abstract_declarator" "'['" "const_exp" "']'")
     ("'('" "abstract_declarator" "')'"))
    ("abstract_declarator" ("direct_abstract_declarator")
     ("pointer" "direct_abstract_declarator") ("pointer"))
    ("type_name" ("spec_qualifier_list")
     ("spec_qualifier_list" "abstract_declarator"))
    ("initializer_list" ("initializer_list" "','" "initializer")
     ("initializer"))
    ("initializer" ("'{'" "initializer_list" "','" "'}'")
     ("'{'" "initializer_list" "'}'") ("assignment_exp"))
    ("id_list" ("id_list" "','" "id") ("id"))
    ("param_decl" ("decl_specs") ("decl_specs" "abstract_declarator")
     ("decl_specs" "declarator"))
    ("param_list" ("param_list" "','" "param_decl") ("param_decl"))
    ("param_type_list" ("param_list" "','" "'...'") ("param_list"))
    ("type_qualifier_list" ("type_qualifier_list" "type_qualifier")
     ("type_qualifier"))
    ("pointer" ("'*'" "pointer") ("'*'" "type_qualifier_list" "pointer")
     ("'*'") ("'*'" "type_qualifier_list"))
    ("direct_declarator" ("direct_declarator" "'('" "')'")
     ("direct_declarator" "'('" "id_list" "')'")
     ("direct_declarator" "'('" "param_type_list" "')'")
     ("direct_declarator" "'['" "']'")
     ("direct_declarator" "'['" "const_exp" "']'")
     ("'('" "declarator" "')'") ("id"))
    ("declarator" ("direct_declarator") ("pointer" "direct_declarator"))
    ("enumerator" ("id" "'='" "const_exp") ("id"))
    ("enumerator_list" ("enumerator_list" "','" "enumerator")
     ("enumerator"))
    ("enum_spec" ("'enum'" "id") ("'enum'" "'{'" "enumerator_list" "'}'")
     ("'enum'" "id" "'{'" "enumerator_list" "'}'"))
    ("struct_declarator" ("':'" "const_exp")
     ("declarator" "':'" "const_exp") ("declarator"))
    ("struct_declarator_list"
     ("struct_declarator_list" "','" "struct_declarator")
     ("struct_declarator"))
    ("spec_qualifier_list" ("type_qualifier")
     ("type_qualifier" "spec_qualifier_list") ("type_spec")
     ("type_spec" "spec_qualifier_list"))
    ("struct_decl" ("spec_qualifier_list" "struct_declarator_list" "';'"))
    ("init_declarator" ("declarator" "'='" "initializer") ("declarator"))
    ("init_declarator_list"
     ("init_declarator_list" "','" "init_declarator") ("init_declarator"))
    ("struct_decl_list" ("struct_decl_list" "struct_decl")
     ("struct_decl"))
    ("struct_or_union" ("'union'") ("'struct'"))
    ("struct_or_union_spec" ("struct_or_union" "id")
     ("struct_or_union" "'{'" "struct_decl_list" "'}'")
     ("struct_or_union" "id" "'{'" "struct_decl_list" "'}'"))
    ("type_qualifier" ("'volatile'") ("'const'"))
    ("type_spec" ("typedef_name") ("enum_spec") ("struct_or_union_spec")
     ("'unsigned'") ("'signed'") ("'double'") ("'float'") ("'long'")
     ("'int'") ("'short'") ("'char'") ("'void'"))
    ("storage_class_spec" ("'typedef'") ("'extern'") ("'static'")
     ("'register'") ("'auto'"))
    ("decl_specs" ("type_qualifier") ("type_qualifier" "decl_specs")
     ("type_spec") ("type_spec" "decl_specs") ("storage_class_spec")
     ("storage_class_spec" "decl_specs"))
    ("decl_list" ("decl_list" "decl") ("decl"))
    ("decl" ("decl_specs" "';'")
     ("decl_specs" "init_declarator_list" "';'"))
    ("function_definition" ("declarator" "compound_stat")
     ("decl_specs" "declarator" "compound_stat")
     ("declarator" "decl_list" "compound_stat")
     ("decl_specs" "declarator" "decl_list" "compound_stat"))
    ("external_decl" ("decl") ("function_definition"))
    ("translation_unit" ("translation_unit" "external_decl")
     ("external_decl"))))


(defparameter *cbnf-symbol-alist*
  '((|const| (|enumeration_const|) (|float_const|) (|char_const|)
     (|int_const|))
    (|argument_exp_list| (|argument_exp_list| |','| |assignment_exp|)
     (|assignment_exp|))
    (|primary_exp| (|'('| |exp| |')'|) (|string|) (|const|) (|id|))
    (|postfix_exp| (|postfix_exp| |'--'|) (|postfix_exp| |'++'|)
     (|postfix_exp| |'->'| |id|) (|postfix_exp| |'.'| |id|)
     (|postfix_exp| |'('| |')'|)
     (|postfix_exp| |'('| |argument_exp_list| |')'|)
     (|postfix_exp| |'['| |exp| |']'|) (|primary_exp|))
    (|unary_operator| (|'!'|) (|'~'|) (|'-'|) (|'+'|) (|'*'|) (|'&'|))
    (|unary_exp| (|'sizeof'| |'('| |type_name| |')'|)
     (|'sizeof'| |unary_exp|) (|unary_operator| |cast_exp|)
     (|'--'| |unary_exp|) (|'++'| |unary_exp|) (|postfix_exp|))
    (|cast_exp| (|'('| |type_name| |')'| |cast_exp|) (|unary_exp|))
    (|mult_exp| (|mult_exp| |'%'| |cast_exp|)
     (|mult_exp| |'/'| |cast_exp|) (|mult_exp| |'*'| |cast_exp|)
     (|cast_exp|))
    (|additive_exp| (|additive_exp| |'-'| |mult_exp|)
     (|additive_exp| |'+'| |mult_exp|) (|mult_exp|))
    (|shift_expression| (|shift_expression| |'>>'| |additive_exp|)
     (|shift_expression| |'<<'| |additive_exp|) (|additive_exp|))
    (|relational_exp| (|relational_exp| |'>='| |shift_expression|)
     (|relational_exp| |'<='| |shift_expression|)
     (|relational_exp| |'>'| |shift_expression|)
     (|relational_exp| |'<'| |shift_expression|) (|shift_expression|))
    (|equality_exp| (|equality_exp| |'!='| |relational_exp|)
     (|equality_exp| |'=='| |relational_exp|) (|relational_exp|))
    (|and_exp| (|and_exp| |'&'| |equality_exp|) (|equality_exp|))
    (|exclusive_or_exp| (|exclusive_or_exp| |'^'| |and_exp|) (|and_exp|))
    (|inclusive_or_exp| (|inclusive_or_exp| |'\|'| |exclusive_or_exp|)
     (|exclusive_or_exp|))
    (|logical_and_exp| (|logical_and_exp| |'&&'| |inclusive_or_exp|)
     (|inclusive_or_exp|))
    (|logical_or_exp| (|logical_or_exp| |'\|\|'| |logical_and_exp|)
     (|logical_and_exp|))
    (|const_exp| (|conditional_exp|))
    (|conditional_exp|
     (|logical_or_exp| |'?'| |exp| |':'| |conditional_exp|)
     (|logical_or_exp|))
    (|assignment_operator| (|'\|='|) (|'^='|) (|'&='|) (|'>>='|) (|'<<='|)
     (|'-='|) (|'+='|) (|'%='|) (|'/='|) (|'*='|) (|'='|))
    (|assignment_exp| (|unary_exp| |assignment_operator| |assignment_exp|)
     (|conditional_exp|))
    (|exp| (|exp| |','| |assignment_exp|) (|assignment_exp|))
    (|jump_stat| (|'return'| |';'|) (|'return'| |exp| |';'|)
     (|'break'| |';'|) (|'continue'| |';'|) (|'goto'| |id| |';'|))
    (|iteration_stat| (|'for'| |'('| |';'| |';'| |')'| |stat|)
     (|'for'| |'('| |';'| |';'| |exp| |')'| |stat|)
     (|'for'| |'('| |';'| |exp| |';'| |')'| |stat|)
     (|'for'| |'('| |';'| |exp| |';'| |exp| |')'| |stat|)
     (|'for'| |'('| |exp| |';'| |';'| |')'| |stat|)
     (|'for'| |'('| |exp| |';'| |';'| |exp| |')'| |stat|)
     (|'for'| |'('| |exp| |';'| |exp| |';'| |')'| |stat|)
     (|'for'| |'('| |exp| |';'| |exp| |';'| |exp| |')'| |stat|)
     (|'do'| |stat| |'while'| |'('| |exp| |')'| |';'|)
     (|'while'| |'('| |exp| |')'| |stat|))
    (|selection_stat| (|'switch'| |'('| |exp| |')'| |stat|)
     (|'if'| |'('| |exp| |')'| |stat| |'else'| |stat|)
     (|'if'| |'('| |exp| |')'| |stat|))
    (|stat_list| (|stat_list| |stat|) (|stat|))
    (|compound_stat| (|'{'| |'}'|) (|'{'| |decl_list| |'}'|)
     (|'{'| |stat_list| |'}'|) (|'{'| |decl_list| |stat_list| |'}'|))
    (|exp_stat| (|';'|) (|exp| |';'|))
    (|labeled_stat| (|'default'| |':'| |stat|)
     (|'case'| |const_exp| |':'| |stat|) (|id| |':'| |stat|))
    (|stat| (|jump_stat|) (|iteration_stat|) (|selection_stat|)
     (|compound_stat|) (|exp_stat|) (|labeled_stat|))
    (|typedef_name| (|id|))
    (|direct_abstract_declarator| (|'('| |')'|)
     (|direct_abstract_declarator| |'('| |')'|)
     (|'('| |param_type_list| |')'|)
     (|direct_abstract_declarator| |'('| |param_type_list| |')'|)
     (|'['| |']'|) (|direct_abstract_declarator| |'['| |']'|)
     (|'['| |const_exp| |']'|)
     (|direct_abstract_declarator| |'['| |const_exp| |']'|)
     (|'('| |abstract_declarator| |')'|))
    (|abstract_declarator| (|direct_abstract_declarator|)
     (|pointer| |direct_abstract_declarator|) (|pointer|))
    (|type_name| (|spec_qualifier_list|)
     (|spec_qualifier_list| |abstract_declarator|))
    (|initializer_list| (|initializer_list| |','| |initializer|)
     (|initializer|))
    (|initializer| (|'{'| |initializer_list| |','| |'}'|)
     (|'{'| |initializer_list| |'}'|) (|assignment_exp|))
    (|id_list| (|id_list| |','| |id|) (|id|))
    (|param_decl| (|decl_specs|) (|decl_specs| |abstract_declarator|)
     (|decl_specs| |declarator|))
    (|param_list| (|param_list| |','| |param_decl|) (|param_decl|))
    (|param_type_list| (|param_list| |','| |'...'|) (|param_list|))
    (|type_qualifier_list| (|type_qualifier_list| |type_qualifier|)
     (|type_qualifier|))
    (|pointer| (|'*'| |pointer|) (|'*'| |type_qualifier_list| |pointer|)
     (|'*'|) (|'*'| |type_qualifier_list|))
    (|direct_declarator| (|direct_declarator| |'('| |')'|)
     (|direct_declarator| |'('| |id_list| |')'|)
     (|direct_declarator| |'('| |param_type_list| |')'|)
     (|direct_declarator| |'['| |']'|)
     (|direct_declarator| |'['| |const_exp| |']'|)
     (|'('| |declarator| |')'|) (|id|))
    (|declarator| (|direct_declarator|) (|pointer| |direct_declarator|))
    (|enumerator| (|id| |'='| |const_exp|) (|id|))
    (|enumerator_list| (|enumerator_list| |','| |enumerator|)
     (|enumerator|))
    (|enum_spec| (|'enum'| |id|) (|'enum'| |'{'| |enumerator_list| |'}'|)
     (|'enum'| |id| |'{'| |enumerator_list| |'}'|))
    (|struct_declarator| (|':'| |const_exp|)
     (|declarator| |':'| |const_exp|) (|declarator|))
    (|struct_declarator_list|
     (|struct_declarator_list| |','| |struct_declarator|)
     (|struct_declarator|))
    (|spec_qualifier_list| (|type_qualifier|)
     (|type_qualifier| |spec_qualifier_list|) (|type_spec|)
     (|type_spec| |spec_qualifier_list|))
    (|struct_decl| (|spec_qualifier_list| |struct_declarator_list| |';'|))
    (|init_declarator| (|declarator| |'='| |initializer|) (|declarator|))
    (|init_declarator_list|
     (|init_declarator_list| |','| |init_declarator|) (|init_declarator|))
    (|struct_decl_list| (|struct_decl_list| |struct_decl|)
     (|struct_decl|))
    (|struct_or_union| (|'union'|) (|'struct'|))
    (|struct_or_union_spec| (|struct_or_union| |id|)
     (|struct_or_union| |'{'| |struct_decl_list| |'}'|)
     (|struct_or_union| |id| |'{'| |struct_decl_list| |'}'|))
    (|type_qualifier| (|'volatile'|) (|'const'|))
    (|type_spec| (|typedef_name|) (|enum_spec|) (|struct_or_union_spec|)
     (|'unsigned'|) (|'signed'|) (|'double'|) (|'float'|) (|'long'|)
     (|'int'|) (|'short'|) (|'char'|) (|'void'|))
    (|storage_class_spec| (|'typedef'|) (|'extern'|) (|'static'|)
     (|'register'|) (|'auto'|))
    (|decl_specs| (|type_qualifier|) (|type_qualifier| |decl_specs|)
     (|type_spec|) (|type_spec| |decl_specs|) (|storage_class_spec|)
     (|storage_class_spec| |decl_specs|))
    (|decl_list| (|decl_list| |decl|) (|decl|))
    (|decl| (|decl_specs| |';'|)
     (|decl_specs| |init_declarator_list| |';'|))
    (|function_definition| (|declarator| |compound_stat|)
     (|decl_specs| |declarator| |compound_stat|)
     (|declarator| |decl_list| |compound_stat|)
     (|decl_specs| |declarator| |decl_list| |compound_stat|))
    (|external_decl| (|decl|) (|function_definition|))
    (|translation_unit| (|translation_unit| |external_decl|)
     (|external_decl|))))


(defparameter *cbnf-symbol*
  '((|translation_unit| |external_decl|)
    (|translation_unit| |translation_unit| |external_decl|)
    (|external_decl| |function_definition|) (|external_decl| |decl|)
    (|function_definition| |decl_specs| |declarator| |decl_list|
     |compound_stat|)
    (|function_definition| |declarator| |decl_list| |compound_stat|)
    (|function_definition| |decl_specs| |declarator| |compound_stat|)
    (|function_definition| |declarator| |compound_stat|)
    (|decl| |decl_specs| |init_declarator_list| |';'|)
    (|decl| |decl_specs| |';'|) (|decl_list| |decl|)
    (|decl_list| |decl_list| |decl|)
    (|decl_specs| |storage_class_spec| |decl_specs|)
    (|decl_specs| |storage_class_spec|)
    (|decl_specs| |type_spec| |decl_specs|) (|decl_specs| |type_spec|)
    (|decl_specs| |type_qualifier| |decl_specs|)
    (|decl_specs| |type_qualifier|) (|storage_class_spec| |'auto'|)
    (|storage_class_spec| |'register'|) (|storage_class_spec| |'static'|)
    (|storage_class_spec| |'extern'|) (|storage_class_spec| |'typedef'|)
    (|type_spec| |'void'|) (|type_spec| |'char'|) (|type_spec| |'short'|)
    (|type_spec| |'int'|) (|type_spec| |'long'|) (|type_spec| |'float'|)
    (|type_spec| |'double'|) (|type_spec| |'signed'|)
    (|type_spec| |'unsigned'|) (|type_spec| |struct_or_union_spec|)
    (|type_spec| |enum_spec|) (|type_spec| |typedef_name|)
    (|type_qualifier| |'const'|) (|type_qualifier| |'volatile'|)
    (|struct_or_union_spec| |struct_or_union| |id| |'{'|
     |struct_decl_list| |'}'|)
    (|struct_or_union_spec| |struct_or_union| |'{'| |struct_decl_list|
     |'}'|)
    (|struct_or_union_spec| |struct_or_union| |id|)
    (|struct_or_union| |'struct'|) (|struct_or_union| |'union'|)
    (|struct_decl_list| |struct_decl|)
    (|struct_decl_list| |struct_decl_list| |struct_decl|)
    (|init_declarator_list| |init_declarator|)
    (|init_declarator_list| |init_declarator_list| |','|
     |init_declarator|)
    (|init_declarator| |declarator|)
    (|init_declarator| |declarator| |'='| |initializer|)
    (|struct_decl| |spec_qualifier_list| |struct_declarator_list| |';'|)
    (|spec_qualifier_list| |type_spec| |spec_qualifier_list|)
    (|spec_qualifier_list| |type_spec|)
    (|spec_qualifier_list| |type_qualifier| |spec_qualifier_list|)
    (|spec_qualifier_list| |type_qualifier|)
    (|struct_declarator_list| |struct_declarator|)
    (|struct_declarator_list| |struct_declarator_list| |','|
     |struct_declarator|)
    (|struct_declarator| |declarator|)
    (|struct_declarator| |declarator| |':'| |const_exp|)
    (|struct_declarator| |':'| |const_exp|)
    (|enum_spec| |'enum'| |id| |'{'| |enumerator_list| |'}'|)
    (|enum_spec| |'enum'| |'{'| |enumerator_list| |'}'|)
    (|enum_spec| |'enum'| |id|) (|enumerator_list| |enumerator|)
    (|enumerator_list| |enumerator_list| |','| |enumerator|)
    (|enumerator| |id|) (|enumerator| |id| |'='| |const_exp|)
    (|declarator| |pointer| |direct_declarator|)
    (|declarator| |direct_declarator|) (|direct_declarator| |id|)
    (|direct_declarator| |'('| |declarator| |')'|)
    (|direct_declarator| |direct_declarator| |'['| |const_exp| |']'|)
    (|direct_declarator| |direct_declarator| |'['| |']'|)
    (|direct_declarator| |direct_declarator| |'('| |param_type_list|
     |')'|)
    (|direct_declarator| |direct_declarator| |'('| |id_list| |')'|)
    (|direct_declarator| |direct_declarator| |'('| |')'|)
    (|pointer| |'*'| |type_qualifier_list|) (|pointer| |'*'|)
    (|pointer| |'*'| |type_qualifier_list| |pointer|)
    (|pointer| |'*'| |pointer|) (|type_qualifier_list| |type_qualifier|)
    (|type_qualifier_list| |type_qualifier_list| |type_qualifier|)
    (|param_type_list| |param_list|)
    (|param_type_list| |param_list| |','| |'...'|)
    (|param_list| |param_decl|)
    (|param_list| |param_list| |','| |param_decl|)
    (|param_decl| |decl_specs| |declarator|)
    (|param_decl| |decl_specs| |abstract_declarator|)
    (|param_decl| |decl_specs|) (|id_list| |id|)
    (|id_list| |id_list| |','| |id|) (|initializer| |assignment_exp|)
    (|initializer| |'{'| |initializer_list| |'}'|)
    (|initializer| |'{'| |initializer_list| |','| |'}'|)
    (|initializer_list| |initializer|)
    (|initializer_list| |initializer_list| |','| |initializer|)
    (|type_name| |spec_qualifier_list| |abstract_declarator|)
    (|type_name| |spec_qualifier_list|) (|abstract_declarator| |pointer|)
    (|abstract_declarator| |pointer| |direct_abstract_declarator|)
    (|abstract_declarator| |direct_abstract_declarator|)
    (|direct_abstract_declarator| |'('| |abstract_declarator| |')'|)
    (|direct_abstract_declarator| |direct_abstract_declarator| |'['|
     |const_exp| |']'|)
    (|direct_abstract_declarator| |'['| |const_exp| |']'|)
    (|direct_abstract_declarator| |direct_abstract_declarator| |'['|
     |']'|)
    (|direct_abstract_declarator| |'['| |']'|)
    (|direct_abstract_declarator| |direct_abstract_declarator| |'('|
     |param_type_list| |')'|)
    (|direct_abstract_declarator| |'('| |param_type_list| |')'|)
    (|direct_abstract_declarator| |direct_abstract_declarator| |'('|
     |')'|)
    (|direct_abstract_declarator| |'('| |')'|) (|typedef_name| |id|)
    (|stat| |labeled_stat|) (|stat| |exp_stat|) (|stat| |compound_stat|)
    (|stat| |selection_stat|) (|stat| |iteration_stat|)
    (|stat| |jump_stat|) (|labeled_stat| |id| |':'| |stat|)
    (|labeled_stat| |'case'| |const_exp| |':'| |stat|)
    (|labeled_stat| |'default'| |':'| |stat|) (|exp_stat| |exp| |';'|)
    (|exp_stat| |';'|)
    (|compound_stat| |'{'| |decl_list| |stat_list| |'}'|)
    (|compound_stat| |'{'| |stat_list| |'}'|)
    (|compound_stat| |'{'| |decl_list| |'}'|)
    (|compound_stat| |'{'| |'}'|) (|stat_list| |stat|)
    (|stat_list| |stat_list| |stat|)
    (|selection_stat| |'if'| |'('| |exp| |')'| |stat|)
    (|selection_stat| |'if'| |'('| |exp| |')'| |stat| |'else'| |stat|)
    (|selection_stat| |'switch'| |'('| |exp| |')'| |stat|)
    (|iteration_stat| |'while'| |'('| |exp| |')'| |stat|)
    (|iteration_stat| |'do'| |stat| |'while'| |'('| |exp| |')'| |';'|)
    (|iteration_stat| |'for'| |'('| |exp| |';'| |exp| |';'| |exp| |')'|
     |stat|)
    (|iteration_stat| |'for'| |'('| |exp| |';'| |exp| |';'| |')'| |stat|)
    (|iteration_stat| |'for'| |'('| |exp| |';'| |';'| |exp| |')'| |stat|)
    (|iteration_stat| |'for'| |'('| |exp| |';'| |';'| |')'| |stat|)
    (|iteration_stat| |'for'| |'('| |';'| |exp| |';'| |exp| |')'| |stat|)
    (|iteration_stat| |'for'| |'('| |';'| |exp| |';'| |')'| |stat|)
    (|iteration_stat| |'for'| |'('| |';'| |';'| |exp| |')'| |stat|)
    (|iteration_stat| |'for'| |'('| |';'| |';'| |')'| |stat|)
    (|jump_stat| |'goto'| |id| |';'|) (|jump_stat| |'continue'| |';'|)
    (|jump_stat| |'break'| |';'|) (|jump_stat| |'return'| |exp| |';'|)
    (|jump_stat| |'return'| |';'|) (|exp| |assignment_exp|)
    (|exp| |exp| |','| |assignment_exp|)
    (|assignment_exp| |conditional_exp|)
    (|assignment_exp| |unary_exp| |assignment_operator| |assignment_exp|)
    (|assignment_operator| |'='|) (|assignment_operator| |'*='|)
    (|assignment_operator| |'/='|) (|assignment_operator| |'%='|)
    (|assignment_operator| |'+='|) (|assignment_operator| |'-='|)
    (|assignment_operator| |'<<='|) (|assignment_operator| |'>>='|)
    (|assignment_operator| |'&='|) (|assignment_operator| |'^='|)
    (|assignment_operator| |'\|='|) (|conditional_exp| |logical_or_exp|)
    (|conditional_exp| |logical_or_exp| |'?'| |exp| |':'|
     |conditional_exp|)
    (|const_exp| |conditional_exp|) (|logical_or_exp| |logical_and_exp|)
    (|logical_or_exp| |logical_or_exp| |'\|\|'| |logical_and_exp|)
    (|logical_and_exp| |inclusive_or_exp|)
    (|logical_and_exp| |logical_and_exp| |'&&'| |inclusive_or_exp|)
    (|inclusive_or_exp| |exclusive_or_exp|)
    (|inclusive_or_exp| |inclusive_or_exp| |'\|'| |exclusive_or_exp|)
    (|exclusive_or_exp| |and_exp|)
    (|exclusive_or_exp| |exclusive_or_exp| |'^'| |and_exp|)
    (|and_exp| |equality_exp|) (|and_exp| |and_exp| |'&'| |equality_exp|)
    (|equality_exp| |relational_exp|)
    (|equality_exp| |equality_exp| |'=='| |relational_exp|)
    (|equality_exp| |equality_exp| |'!='| |relational_exp|)
    (|relational_exp| |shift_expression|)
    (|relational_exp| |relational_exp| |'<'| |shift_expression|)
    (|relational_exp| |relational_exp| |'>'| |shift_expression|)
    (|relational_exp| |relational_exp| |'<='| |shift_expression|)
    (|relational_exp| |relational_exp| |'>='| |shift_expression|)
    (|shift_expression| |additive_exp|)
    (|shift_expression| |shift_expression| |'<<'| |additive_exp|)
    (|shift_expression| |shift_expression| |'>>'| |additive_exp|)
    (|additive_exp| |mult_exp|)
    (|additive_exp| |additive_exp| |'+'| |mult_exp|)
    (|additive_exp| |additive_exp| |'-'| |mult_exp|)
    (|mult_exp| |cast_exp|) (|mult_exp| |mult_exp| |'*'| |cast_exp|)
    (|mult_exp| |mult_exp| |'/'| |cast_exp|)
    (|mult_exp| |mult_exp| |'%'| |cast_exp|) (|cast_exp| |unary_exp|)
    (|cast_exp| |'('| |type_name| |')'| |cast_exp|)
    (|unary_exp| |postfix_exp|) (|unary_exp| |'++'| |unary_exp|)
    (|unary_exp| |'--'| |unary_exp|)
    (|unary_exp| |unary_operator| |cast_exp|)
    (|unary_exp| |'sizeof'| |unary_exp|)
    (|unary_exp| |'sizeof'| |'('| |type_name| |')'|)
    (|unary_operator| |'&'|) (|unary_operator| |'*'|)
    (|unary_operator| |'+'|) (|unary_operator| |'-'|)
    (|unary_operator| |'~'|) (|unary_operator| |'!'|)
    (|postfix_exp| |primary_exp|)
    (|postfix_exp| |postfix_exp| |'['| |exp| |']'|)
    (|postfix_exp| |postfix_exp| |'('| |argument_exp_list| |')'|)
    (|postfix_exp| |postfix_exp| |'('| |')'|)
    (|postfix_exp| |postfix_exp| |'.'| |id|)
    (|postfix_exp| |postfix_exp| |'->'| |id|)
    (|postfix_exp| |postfix_exp| |'++'|)
    (|postfix_exp| |postfix_exp| |'--'|) (|primary_exp| |id|)
    (|primary_exp| |const|) (|primary_exp| |string|)
    (|primary_exp| |'('| |exp| |')'|)
    (|argument_exp_list| |assignment_exp|)
    (|argument_exp_list| |argument_exp_list| |','| |assignment_exp|)
    (|const| |int_const|) (|const| |char_const|) (|const| |float_const|)
    (|const| |enumeration_const|)))
