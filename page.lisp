;; ================================================================ ;;
;;                                                                  ;;
;;   PaGe :: Parser Generator for LALR(1)-grammar by Common Lisp    ;;
;;                                                                  ;;
;; ================================================================ ;;

;; (defpackage :page
;;   (:use :cl-user))
;; (in-package 'page)

(defstruct (grammar
	    (:constructor make-grammar (start rules)))
  start (rules () :type list))

;; --------------------------------
;;  rule
;; 
;; * id : to distinguish rules
;; * lhs -> rhs
(defstruct (rule
	    (:constructor make-rule (lhs rhs)))
  (id nil :type number)
  (lhs nil)
  (rhs nil))

(declaim (inline rule=))
(defun rule= (r1 r2)
  (declare (type rule r1 r2))
  (eq r1 r2))
;  (= (rule-id r1) (rule-id r2)))

(defun rule< (r1 r2)
  (< (rule-id r1) (rule-id r2)))
(declaim (inline rule<))



;; 
;; grammar represented by numbers (and symbol-number table)
;; 
(defstruct (canonical-grammar
	    (:conc-name cg-)
	    (:constructor make-canonical-grammar
	      (start rules nt-num num sym-array sym-alist unknown-symbol)))
  (start :type number)
  (rules :type list)
  (nt-num :type number)
  (num :type number)
  (sym-array :type array)
  (sym-alist :type list)
  unknown-symbol
  (nullable-array nil)			; bit array
  (first-array nil)
  (follow-array nil)
  (first-symbols-array nil)
  )


(defun canonicalize (grammar &key start eof (unknown-symbol ""))
  (let* ((ntset (remove-duplicates (mapcar #'car (grammar-rules grammar)) :test #'equal))
	 (tset (set-difference (remove-duplicates (apply #'append (mapcar #'cdr (grammar-rules grammar))) :test #'equal) ntset :test #'equal))
	 (symbol-alist nil)
	 (nt-num 1)
	 (num 0))
    ;; numbering to non-terminal symbol
    (loop for symbol in ntset
	  do (push (cons symbol nt-num) symbol-alist)
	     (incf nt-num))
    (setf num nt-num)
    ;; numbering to terminal symbol
    (loop for symbol in tset
	  do (push (cons symbol num) symbol-alist)
	     (incf num))
    ;; make symbol-array and canonical-grammar
    (let ((symbol-array (make-array (+ num 1) :initial-element nil))
	  (rules (cons (make-rule 0 (list (cdr (assoc (grammar-start grammar) symbol-alist :test #'equal)) num))
		       (mapcar #'(lambda (rule)
				   (let ((r (mapcar #'(lambda (x) (cdr (assoc x symbol-alist :test #'equal))) rule)))
				     (make-rule (car r) (cdr r)))) (grammar-rules grammar)))))
      (dolist (sym-num symbol-alist)
	(setf (aref symbol-array (cdr sym-num)) (car sym-num)))
      (let ((rule-num 0))
	(dolist (rule rules)
	  (setf (rule-id rule) rule-num)
	  (incf rule-num)))
      (setf (aref symbol-array 0) start (aref symbol-array num) eof)
      ;; replace symbol to index
      (make-canonical-grammar
       (cdr (assoc (grammar-start grammar) symbol-alist :test #'equal))
       rules
       nt-num num symbol-array symbol-alist unknown-symbol))))


(defun cg-symbol (cg n &key (unknown t))
  ;; (declare (canonical-grammar cg))
  (if (<= n (cg-num cg))
      (aref (cg-sym-array cg) n)
      (when unknown (cg-unknown-symbol cg))))

(defun cg-nullable (cg n)
  ;; (declare (canonical-grammar cg))
  (unless (cg-nullable-array cg) (calc-nullable cg))
  (= 1 (aref (cg-nullable-array cg) n)))

(defun cg-first (cg n)
  ;; (declare (canonical-grammar cg))
  (unless (cg-first-array cg) (calc-first cg))
  (aref (cg-first-array cg) n))

(defun cg-follow (cg n)
  ;; (declare (canonical-grammar cg))
  (unless (cg-follow-array cg) (calc-follow cg))
  (aref (cg-follow-array cg) n))

(defun cg-non-terminal-p (cg num)
  ;; (declare (canonical-grammar cg))
  (< num (cg-nt-num cg)))

(defun cg-terminal-p (cg num)
  (declare (canonical-grammar cg))
  (<= (cg-nt-num cg) num))

(defun foldl (e op l)
  (if l (foldl (funcall op e (first l)) op (rest l)) e))

(defun filter (predicate sequence)
  (when sequence
    (destructuring-bind (x . ls) sequence
      (if (funcall predicate x)
	  (cons x (filter predicate ls))
	  (filter predicate ls)))))

(defun take (n l)
  (if (< 0 n) (cons (first l) (take (- n 1) (rest l))) nil))

(defun rev-take (n l)
  (let ((result nil)
	(l1 (copy-list l)))
    (dotimes (i n result)
      (push (pop l1) result))))
      
(defun drop (n l)
  (if (< 0 n) (drop (- n 1) (rest l)) l))

(defun set-eq (s1 s2 &key (test #'equal))
  (null (set-exclusive-or s1 s2 :test test)))

;; nullability-checker
(defun calc-nullable (cg)
  (let ((nullable (make-array (+ (cg-num cg) 1) :element-type 'bit :initial-element 0))
	(changed t))
    ;; initialize
    (loop while changed
	  do (setf changed nil)
	     (dolist (rule (cg-rules cg))
	       (when (or (null (rule-rhs rule)) ; X -> 
			 (every #'(lambda (n) (= 1 (aref nullable n))) (rule-rhs rule))) ; X -> Y_1 .. Y_n s.t. all Y_i is nullable.
		 ;; only false -> true
		 (when (= 0 (aref nullable (rule-lhs rule)))
		   (setf (aref nullable (rule-lhs rule)) 1
			 changed t)))))
    (setf (cg-nullable-array cg) nullable)))

(defun cg-sequence-nullable (cg sequence)
  (let ((nullable t))
    (loop while nullable
	  for s in sequence
	  do (setf nullable (cg-nullable cg s)))
    nullable))

;; 
(defun calc-first (cg)
  (let ((firsts (make-array (+ (cg-num cg) 1) :initial-element '()))
	(changed t))
    (loop for n from (cg-nt-num cg) to (cg-num cg)
	  do (setf (aref firsts n) (list n)))
    (loop while changed
	  do (setf changed nil)
	     (dotimes (X (cg-nt-num cg))
	       (let ((old-x-firsts (copy-list (aref firsts X))))
		 ;; all [X -> Y_1 .. Y_n]s
		 (dolist (rule (cg-rules cg))
		   (when (= X (rule-lhs rule))
		     (let ((all-null t))
		       (loop while all-null
			     for Y in (rule-rhs rule)
			     do (let ((y-firsts (aref firsts Y))
				      (null-exists nil))
				  (dolist (symbol y-firsts)
				    (if (null symbol)
					(setf null-exists t)
					(pushnew symbol (aref firsts X) :test #'=)))
				  ;; if nil isn't in y-firsts, we don't have to look rest [Y_i]s.
				  (unless null-exists (setf all-null nil))))
		       ;; n = 0 or all Y_i's firsts has nil.
		       (when all-null
			 (pushnew nil (aref firsts X) :test #'equal)))))
		 (unless (set-eq old-x-firsts (aref firsts X))
		   (setf changed t)))))
    (setf (cg-first-array cg) firsts)))
		     
(defun nt-derive-first (cg symbol &optional (seen nil))
  (let ((rules (cg-rules cg))
	(result nil))
    (dolist (rule rules result)
      (when (and (= symbol (rule-lhs rule))
		 (rule-rhs rule))
	(let ((X (first (rule-rhs rule))))
	  (when (and (cg-non-terminal-p cg X)
		     (not (member X seen)))
	    (pushnew X result)
	    (setf result (union result (nt-derive-first cg X (cons symbol seen))))))))))
	

		 
	


(defun cg-sequence-first (cg sequence)
  (if (null sequence) nil
      (let ((firsts (cg-first cg (first sequence))))
	(if (member () firsts)
	    (union firsts (cg-sequence-first cg (rest sequence)))
	    firsts))))

(defun calc-follow (cg)
  (let ((follows (make-array (+ (cg-num cg) 1) :initial-element nil))
	(changed t))
    (push (cg-num cg) (aref follows (cg-start cg)))
    (loop while changed
	  do (setf changed nil)
	     (dolist (rule (cg-rules cg))
	       (let ((A (rule-lhs rule)))
		 (labels ((f (symbol-list)
			    (let ((B (first symbol-list)))
			      (when (cg-non-terminal-p  cg B)
				(let ((rest-firsts (cg-sequence-first cg (rest symbol-list))))
				  ;; [ A -> aB ] or [ A -> aBb /\ () in First(b) ]
				  (when (or (null rest-firsts) (member nil rest-firsts :test #'equal))
				    (dolist (symbol (aref follows A))
				      (unless (member symbol (aref follows B))
					(push symbol (aref follows B))
					(setf changed t))))
				  (dolist (symbol rest-firsts)
				    (unless (or (null symbol) (member symbol (aref follows B) :test #'equal))
				      (push symbol (aref follows B))
				      (setf changed t))))))))
		   (maplist #'f (rule-rhs rule))))))
    (setf (cg-follow-array cg) follows)))
  


;; --------------------------------
;;  LR parser
;; 

;; ----------------------------------
;;  lr-item
;; 
(defstruct (item 
	    (:constructor make-item (rule position)))
  (rule :type rule)
  (position :type number))

(defun item-lhs (item) (rule-lhs (item-rule item)))
(defun item-rhs (item) (rule-rhs (item-rule item)))
(defun item-pre (item) (take (item-position item) (item-rhs item)))
(defun item-suc (item) (drop (item-position item) (item-rhs item)))
(defun item-suc-null (item)
  (= (item-position item) (length (item-rhs item))))
(defun item-next (item)
  (declare (optimize (speed 3) (space 0)))
  (nth (item-position item) (item-rhs item)))

(declaim (inline item=))
(defun item= (i1 i2)
  (declare (type item i1 i2))
  (or (eq i1 i2)
      (and (rule= (item-rule i1) (item-rule i2))
	   (= (item-position i1) (item-position i2)))))

(defun item< (i1 i2)
  ;; (declare (type item i1 i2))
  (cond ((eq i1 i2) nil)
	((rule< (item-rule i1) (item-rule i2)) t)
	((rule= (item-rule i1) (item-rule i2))
	 (< (item-position i1) (item-position i2)))
	(t nil)))

(declaim (inline (item-lhs item-rhs item-pre item-suc item-next item= item<)))

(defun shift-item (item)
  (unless (item-suc-null item)
    (make-item
     (item-rule item)
     (+ (item-position item) 1))))

(defun cg-print-item (cg item &key (stream t))
  (format stream "~S -> ~{~S~^ ~} .. ~{~S~^ ~}"
	  (cg-symbol cg (item-lhs item))
	  (mapcar #'(lambda (x) (cg-symbol cg x)) (reverse (item-pre item)))
	  (mapcar #'(lambda (x) (cg-symbol cg x)) (item-suc item))))


(defstruct (kernel
	    (:constructor make-kernel-base))
  (items :type list)
  (gotos :type list))

(defun make-kernel (&key items gotos)
  (make-kernel-base :items (sort items #'item<) :gotos gotos))

(defun kernel= (k1 k2)
  (declare (optimize (speed 3) (space 0)))
  (declare (type kernel k1 k2))
  (or (eq k1 k2)
      (do* ((l1 (kernel-items k1) (cdr l1)) (l2 (kernel-items k2) (cdr l2))
	    (x (car l1) (car l1)) (y (car l2) (car l2)))
	   ((or (null l1) (null l2)) (eq l1 l2))
	(unless (item= x y) (return nil)))))


(defun cg-print-kernel (cg kernel &key (stream t))
  (format stream "~{[~a]~%~}~{~a~^~%~}"
	  (mapcar #'(lambda (x) (cg-print-item cg x :stream nil)) (kernel-items kernel))
	  (mapcar #'(lambda (x) (cons (cg-symbol cg (car x)) (cdr x))) (kernel-gotos kernel))
	  ))

(defun cg-print-all-kernel (cg kernel-array &key (stream t))
  (let ((n (length kernel-array)))
    (dotimes (i n)
      (format stream "~%" i)
      (cg-print-kernel cg (aref kernel-array i) :stream stream))))

(defun cg-first-symbols (cg n)
  (unless (cg-first-symbols-array cg)
    (setf (cg-first-symbols-array cg) (make-array (+ (cg-num cg) 1) :initial-element :undefined)))
  (aref (cg-first-symbols-array cg) n))

(defun first-symbols (cg n &optional (visited nil))
  (declare (optimize (speed 3) (space 0)))
  (cond ((cg-terminal-p cg n) (list n))
	((member n visited) nil)
	(t (let ((result (cg-first-symbols cg n)))
	     (when (eq result :undefined)
	       (setf result (list n))
	       (dolist (rule (cg-rules cg))
		 (when (and (= n (rule-lhs rule)) (rule-rhs rule))
		   (setf result (union result (first-symbols cg (first (rule-rhs rule)) (cons n visited)))))))
	     (unless visited (setf (aref (cg-first-symbols-array cg) n) result))
	     result))))

;; Kernel of GOTO(I,X)
(defun calc-goto (cg kernel symbol)
  (declare (optimize (speed 3) (space 0)))
  (declare (type kernel kernel))
  (let ((result nil))
    (dolist (item (kernel-items kernel))
      (unless (item-suc-null item)
	(when (= symbol (item-next item))
	  (pushnew (shift-item item) result :test #'item=))
	(dolist (rule (cg-rules cg))
	  (when (and (rule-rhs rule)
		     (= symbol (first (rule-rhs rule)))
		     (member (rule-lhs rule) (first-symbols cg (item-next item)) :test #'=))
	    (pushnew (shift-item (make-item rule 0)) result :test #'item=)))))
    result))

(defun calc-kernels (cg)
  (declare (optimize (speed 3) (space 0)))
  (let* ((init-kernel (make-kernel :items (list (make-item (first (cg-rules cg)) 0)) :gotos nil))
	 (kernel-ht (make-hash-table :test 'kernel=))
	 (kernel-list (list (cons init-kernel 0)))
	 (num 0))
    (labels ((f (kernels)
	       (when kernels
		 (let ((added nil))
		   (labels ((g (x kernel)
			      (let ((goto (calc-goto cg kernel x)))
				(when goto
				  (let* ((k (make-kernel :items goto :gotos nil))
					 (next (gethash k kernel-ht nil)))
				    (unless next
				      (incf num)
				      (setf next num)
				      (push (cons k next) kernel-list)
				      (setf (gethash k kernel-ht) next)
				      (push k added))
				    (pushnew (cons x next) (kernel-gotos kernel) :test #'equal))))))
		     (dolist (kernel kernels)
		       (let ((symbols nil))
		       	 (dolist (item (kernel-items kernel))
		       	   (when (item-suc item) (pushnew (item-next item) symbols)))
		       	 (dolist (rule (cg-rules cg))
		       	   (when (rule-rhs rule) (pushnew (first (rule-rhs rule)) symbols)))
		       	 (dolist (s symbols) (g s kernel))))
		   (f added))))))
      (f (list init-kernel))
      (let ((kernel-array (make-array (length kernel-list))))
	(dolist (k-n kernel-list kernel-array)
	  (setf (aref kernel-array (cdr k-n)) (car k-n)))))))


;; ================================
;;  DeRemer
;; TODO: OPTIMIZATION

(defun get-goto-array (kernel-array)
  (let* ((n (length kernel-array))
	 (ga (make-array n :initial-element nil)))
    (dotimes (i n ga)
      (setf (aref ga i) (kernel-gotos (aref kernel-array i))))))

(defstruct (relation
	    (:constructor make-relation (rels test)))
  (rels :type list)
  (test :type function))

(defstruct (parser
	    (:constructor make-parser (grammar kernel-array)))
  grammar
  kernel-array 
  (transitions nil :type list)
  (direct-read nil :type list)
  (reads nil :type relation)
  (read-set nil :type list)
  (includes nil :type relation)
  (follow-set :type list)
  (lookback :type relation)
  (lookahead-set :type list)
  )

(defun calc-transitions (parser)
  (let ((result nil)
	(n (length (parser-kernel-array parser))))
    (dotimes (i n)
      (setf result (union result (mapcar #'(lambda (x) (cons i (car x))) (kernel-gotos (parser-kernel parser i))))))
    (setf (parser-transitions parser) result)))

(defun parser-kernel (parser n)
  ;; (when (and (<= 0 n) (< n (length (parser-kernel-array parser))))
  (aref (parser-kernel-array parser) n))

;; 
;; DR(p,A)
(defun calc-direct-read (parser)
  (let ((dr-set nil)
	(n (length (parser-kernel-array parser))))
    (dotimes (i n)
      (let ((k (parser-kernel parser i)))
	(dolist (transition (kernel-gotos k))
	  (push (cons (cons i (car transition))
		      (remove-if-not #'(lambda (x) (cg-terminal-p (parser-grammar parser) x))
				     (mapcar #'car (kernel-gotos (parser-kernel parser (cdr transition))))))
		dr-set))))
    (setf (parser-direct-read parser) dr-set)))

;; note: we don't have to calculate before the calculating lookaheads
(defun calc-reads (parser)
  (let ((reads nil)
	(n (length (parser-kernel-array parser)))
	(exist-nullable nil))
    (loop until exist-nullable
	  for i from 0 to (- (cg-num (parser-grammar parser)) 1)
	  do (setf exist-nullable (cg-nullable (parser-grammar parser) i)))
    (if exist-nullable
	(progn
	  (dotimes (i n)
	    (dolist (transition (kernel-gotos (parser-kernel parser i)) reads)
	      (push (cons (cons i (car transition))
			  (mapcar #'(lambda (x) (cons (cdr transition) x))
				  (remove-if-not #'(lambda (x) (cg-nullable (parser-grammar parser) x))
						 (mapcar #'car (kernel-gotos (parser-kernel parser (cdr transition)))))))
		    reads)))
	  (setf (parser-reads parser) (make-relation reads #'(lambda (x y) (and (= (car x) (car y)) (= (cdr x) (cdr y)))))))
	(setf (parser-reads parser) (make-relation nil #'(lambda (x y) t))))))

(defun cg-print-reads (parser)
  (dolist (r (parser-reads parser))
    (destructuring-bind (dom . cod) r
      (format t "~a reads ~{~a~^,~}~%"
	      (cons (car dom) (cg-symbol (parser-grammar parser) (cdr dom)))
	      (mapcar #'(lambda (x) (cons (car x) (cg-symbol (parser-grammar parser) (cdr x)))) cod)))))

;; assoc using equal
(defun assoceq (item alist)
  ;; (assoc item alist :test #'(lambda (x y) (and (= (car x) (car y)) (= (cdr x) (cdr y))))))
  (assoc item alist :test #'equal))

;; 
;; algorithm: Digraph
(defun alg-digraph (node-list rel base-f)
  (let ((result-f nil)
	(stack nil)
	(depth 0)
	(test (relation-test rel))
	(nar (make-hash-table :test #'equal)))
    (declare (optimize (speed 3) (space 0)))
    (declaim (inline test))
    (dolist (node node-list) (push (cons node nil) result-f))
    (labels ((traverse (x)
	       (declare (optimize (speed 3) (space 0)))
	       (push x stack)
	       (incf depth)
	       (setf (gethash x nar) depth)
	       (setf (cdr (assoc x result-f :test test)) (cdr (assoc x base-f :test test)))
	       (dolist (y (cdr (assoc x (relation-rels rel) :test test)))
		 (when (= 0 (gethash y nar 0)) (traverse y))
		 (setf (gethash x nar) (min (gethash x nar 0) (gethash y nar 0)))
		 (setf (cdr (assoc x result-f :test test)) (union (cdr (assoc x result-f :test test)) (cdr (assoc y result-f :test test)) :test #'equal)))
	       (when (= depth (gethash x nar 0))
		 (loop do (setf (gethash (first stack) nar) most-positive-fixnum)
			  (unless (equal (first stack) x)
			    (setf (cdr (assoc (first stack) result-f :test test)) (cdr (assoc x result-f :test test)))
			    )
		       until (equal x (pop stack))))))
      (dolist (node node-list result-f)
	(when (= 0 (gethash node nar 0)) (traverse node))))))

(defun detect-loop (rel x &key (visited nil) (test #'eql))
  ;; (format t "[~a,~a,~a,~a]~%" rel x visited test)
  (let ((found nil))
    (loop until found
	  for s in (cdr (assoc x rel :test test))
	  do (if (member x visited :test test)
		 (setf found t)
		 (setf found (detect-loop rel s :visited (cons x visited) :test test))))
    found))

(defun calc-read-set (parser)
  (let* ((nt-transitions (filter #'(lambda (transition) (cg-non-terminal-p (parser-grammar parser) (cdr transition)))
				 (parser-transitions parser))))
    ;; making node-list
    (setf (parser-read-set parser) (alg-digraph nt-transitions (parser-reads parser) (parser-direct-read parser)))))

(defun rev-traverse (parser starts sequence)
  (declare (optimize (speed 3) (space 0)))
  (if sequence
      (let ((preds nil))
	(dotimes (n (length (parser-kernel-array parser)))
	  (let ((b nil))
	  (loop until b
		for x in (kernel-gotos (parser-kernel parser n))
		do (when (and (= (car x) (first sequence)) (member (cdr x) starts))
		     (push n preds)
		     (setf b t)))))
	  ;; (when (intersection (mapcar #'(lambda (x) (cons (first sequence) x)) starts)
	  ;; 		      (kernel-gotos (parser-kernel parser n)) :test #'equal)
	  ;; (when (intersection starts
	  ;; 		      (mapcar #'cdr (filter #'(lambda (x) (= (first sequence) (car x))) (kernel-gotos (parser-kernel parser n)))) :test #'=)
	    ;; (push n preds)))
	(rev-traverse parser preds (rest sequence)))
      starts))

(defun calc-includes (parser)
  (let* ((cg (parser-grammar parser))
	 (rules (cg-rules cg))
	 (nt-transitions (filter #'(lambda (transition) (cg-non-terminal-p cg (cdr transition)))
				 (parser-transitions parser)))
	 (result nil))
    (dolist (transition nt-transitions)	; transition = (p, A)
      (dolist (rule rules)		; rule = X -> aYb
	(let ((rhs (copy-list (rule-rhs rule)))
	      (pre nil))
	  (loop while rhs
		do (when (and (= (first rhs) (cdr transition))
			      (cg-sequence-nullable cg (rest rhs)))
		     (let* ((starts (rev-traverse parser (list (car transition)) pre))
			    (available (intersection (mapcar #'(lambda (x) (cons x (rule-lhs rule))) starts)
						     nt-transitions
						     :test #'equal)))
		       (if (assoceq (cons (car transition) (first rhs)) result)
			   (setf (cdr (assoceq transition result))
				 (union available (cdr (assoceq transition result))) )
			   (push (cons transition available) result))))
		   (push (pop rhs) pre)))))
    (setf (parser-includes parser) (make-relation result #'equal))))


(defun calc-follow-set (parser)
  (let* ((nt-transitions (filter #'(lambda (transition) (cg-non-terminal-p (parser-grammar parser) (cdr transition)))
				 (parser-transitions parser))))
    (setf (parser-follow-set parser) (alg-digraph nt-transitions (parser-includes parser) (parser-read-set parser)))))

(defun calc-lookback (parser)
  (let ((result nil))
    (dotimes (n (length (parser-kernel-array parser)))
      (dolist (item (kernel-items (parser-kernel parser n)))
	(when (item-suc-null item)
	  (let ((ps (rev-traverse parser (list n) (reverse (item-pre item)))))
	    (when ps
	      (push (cons (cons n (item-rule item)) (mapcar #'(lambda (p) (cons p (item-lhs item))) ps)) result))))))
    (setf (parser-lookback parser) (make-relation result #'equal))))

(defun calc-lookahead-set (parser)
  (let ((result nil))
    (dolist (lb (relation-rels (parser-lookback parser)))
      (push (cons (car lb)
		  (remove-duplicates
		   (apply #'append (mapcar #'(lambda (transition) (cdr (assoc transition (parser-follow-set parser) :test #'equal))) (cdr lb)))
		   :test #'equal)) result))
    (setf (parser-lookahead-set parser) result)))

;; grammar samples
(defparameter *g1*
  (make-grammar "E"
             '(("E" "E" "+" "T") ("E" "T") ("T" "T" "*" "F") ("T" "F")
	       ("F" "(" "E" ")") ("F" "id")))) 
(defparameter *g2*
  (make-grammar "S" '(("S" "id") ("S" "S" "," "id")))) 
(defparameter *g3*
  (make-grammar "S" '(("S" "A") ("S" "S" "A")))) 
(defparameter *g4*
  (make-grammar "S" '(("S" "A") ("S" "A" "S")))) 
(defparameter *g5*
  (make-grammar "S" '(("S" "int" "L") ("L" "id") ("L" "L" "," "id")))) 
(defparameter *g6*
  (make-grammar "S"
             '(("S" "L" "=" "R") ("S" "R") ("L" "*" "R") ("L" "id")
	       ("R" "L")))) 
(defparameter *g7*
  (make-grammar "S" '(("S" "C" "C") ("C" "B" "C") ("C" "D")))) 
(defparameter *g8*
  (make-grammar "S"
             '(("S" "L" "=" "E") ("L" "id") ("L" "R" "^" "id")
              ("E" "E" "+" "R") ("E" "R") ("E" "@" "L") ("R" "id")))) 
(defparameter *G9*
  (make-grammar "A" '(("A" "b" "B") ("B" "c" "C") ("C" "d" "A") ("A" "a"))))
(defparameter *G10*
  (make-grammar "A" '(("A" "B" "C" "D" "A") ("B") ("C") ("D") ("A" "a")))) 
(defparameter *g11*
  (make-grammar "S" '(("S" "A" "B") ("A") ("B") ("A" "x"))))


(defparameter *cbnf*
  (make-grammar "translation_unit"
	     '(("translation_unit" "external_decl")
	       ("translation_unit" "translation_unit" "external_decl")
	       ("external_decl" "function_definition")
	       ("external_decl" "decl")
	       ("function_definition" "decl_specs" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "decl_specs" "declarator" "compound_stat")
	       ("function_definition" "declarator" "compound_stat")
	       ("decl" "decl_specs" "init_declarator_list" "';'")
	       ("decl" "decl_specs" "';'")
	       ("decl_list" "decl")
	       ("decl_list" "decl_list" "decl")
	       ("decl_specs" "storage_class_spec" "decl_specs")
	       ("decl_specs" "storage_class_spec")
	       ("decl_specs" "type_spec" "decl_specs")
	       ("decl_specs" "type_spec")
	       ("decl_specs" "type_qualifier" "decl_specs")
	       ("decl_specs" "type_qualifier")
	       ("storage_class_spec" "'auto'")
	       ("storage_class_spec" "'register'")
	       ("storage_class_spec" "'static'")
	       ("storage_class_spec" "'extern'")
	       ("storage_class_spec" "'typedef'")
	       ("type_spec" "'void'")
	       ("type_spec" "'char'")
	       ("type_spec" "'short'")
	       ("type_spec" "'int'")
	       ("type_spec" "'long'")
	       ("type_spec" "'float'")
	       ("type_spec" "'double'")
	       ("type_spec" "'signed'")
	       ("type_spec" "'unsigned'")
	       ("type_spec" "struct_or_union_spec")
	       ("type_spec" "enum_spec")
	       ("type_spec" "typedef_name")
	       ("type_qualifier" "'const'")
	       ("type_qualifier" "'volatile'")
	       ("struct_or_union_spec" "struct_or_union" "id" "'\{'" "struct_decl_list" "'\}'")
	       ("struct_or_union_spec" "struct_or_union" "'\{'" "struct_decl_list" "'\}'")
	       ("struct_or_union_spec" "struct_or_union" "id")
	       ("struct_or_union" "'struct'")
	       ("struct_or_union" "'union'")
	       ("struct_decl_list" "struct_decl")
	       ("struct_decl_list" "struct_decl_list" "struct_decl")
	       ("init_declarator_list" "init_declarator")
	       ("init_declarator_list" "init_declarator_list" "','" "init_declarator")
	       ("init_declarator" "declarator")
	       ("init_declarator" "declarator" "'='" "initializer")
	       ("struct_decl" "spec_qualifier_list" "struct_declarator_list" "';'")
	       ("spec_qualifier_list" "type_spec" "spec_qualifier_list")
	       ("spec_qualifier_list" "type_spec")
	       ("spec_qualifier_list" "type_qualifier" "spec_qualifier_list")
	       ("spec_qualifier_list" "type_qualifier")
	       ("struct_declarator_list" "struct_declarator")
	       ("struct_declarator_list" "struct_declarator_list" "','" "struct_declarator")
	       ("struct_declarator" "declarator")
	       ("struct_declarator" "declarator" "':'" "const_exp")
	       ("struct_declarator" "':'" "const_exp")
	       ("enum_spec" "'enum'" "id" "'\{'" "enumerator_list" "'\}'")
	       ("enum_spec" "'enum'" "'\{'" "enumerator_list" "'\}'")
	       ("enum_spec" "'enum'" "id")
	       ("enumerator_list" "enumerator")
	       ("enumerator_list" "enumerator_list" "','" "enumerator")
	       ("enumerator" "id")
	       ("enumerator" "id" "'='" "const_exp")
	       ("declarator" "pointer" "direct_declarator")
	       ("declarator" "direct_declarator")
	       ("direct_declarator" "id")
	       ("direct_declarator" "'('" "declarator" "')'")
	       ("direct_declarator" "direct_declarator" "'['" "const_exp" "']'")
	       ("direct_declarator" "direct_declarator" "'['" "']'")
	       ("direct_declarator" "direct_declarator" "'('" "param_type_list" "')'")
	       ("direct_declarator" "direct_declarator" "'('" "id_list" "')'")
	       ("direct_declarator" "direct_declarator" "'('" "')'")
	       ("pointer" "'*'" "type_qualifier_list")
	       ("pointer" "'*'")
	       ("pointer" "'*'" "type_qualifier_list" "pointer")
	       ("pointer" "'*'" "pointer")
	       ("type_qualifier_list" "type_qualifier")
	       ("type_qualifier_list" "type_qualifier_list" "type_qualifier")
	       ("param_type_list" "param_list")
	       ("param_type_list" "param_list" "','" "'...'")
	       ("param_list" "param_decl")
	       ("param_list" "param_list" "','" "param_decl")
	       ("param_decl" "decl_specs" "declarator")
	       ("param_decl" "decl_specs" "abstract_declarator")
	       ("param_decl" "decl_specs")
	       ("id_list" "id")
	       ("id_list" "id_list" "','" "id")
	       ("initializer" "assignment_exp")
	       ("initializer" "'\{'" "initializer_list" "'\}'")
	       ("initializer" "'\{'" "initializer_list" "','" "'\}'")
	       ("initializer_list" "initializer")
	       ("initializer_list" "initializer_list" "','" "initializer")
	       ("type_name" "spec_qualifier_list" "abstract_declarator")
	       ("type_name" "spec_qualifier_list")
	       ("abstract_declarator" "pointer")
	       ("abstract_declarator" "pointer" "direct_abstract_declarator")
	       ("abstract_declarator" "direct_abstract_declarator")
	       ("direct_abstract_declarator" "'('" "abstract_declarator" "')'")
	       ("direct_abstract_declarator" "direct_abstract_declarator" "'['" "const_exp" "']'")
	       ("direct_abstract_declarator" "'['" "const_exp" "']'")
	       ("direct_abstract_declarator" "direct_abstract_declarator" "'['" "']'")
	       ("direct_abstract_declarator" "'['" "']'")
	       ("direct_abstract_declarator" "direct_abstract_declarator" "'('" "param_type_list" "')'")
	       ("direct_abstract_declarator" "'('" "param_type_list" "')'")
	       ("direct_abstract_declarator" "direct_abstract_declarator" "'('" "')'")
	       ("direct_abstract_declarator" "'('" "')'")
	       ("typedef_name" "id")
	       ("stat" "labeled_stat")
	       ("stat" "exp_stat")
	       ("stat" "compound_stat")
	       ("stat" "selection_stat")
	       ("stat" "iteration_stat")
	       ("stat" "jump_stat")
	       ("labeled_stat" "id" "':'" "stat")
	       ("labeled_stat" "'case'" "const_exp" "':'" "stat")
	       ("labeled_stat" "'default'" "':'" "stat")
	       ("exp_stat" "exp" "';'")
	       ("exp_stat" "';'")
	       ("compound_stat" "'\{'" "decl_list" "stat_list" "'\}'")
	       ("compound_stat" "'\{'" "stat_list" "'\}'")
	       ("compound_stat" "'\{'" "decl_list" "'\}'")
	       ("compound_stat" "'\{'" "'\}'")
	       ("stat_list" "stat")
	       ("stat_list" "stat_list" "stat")
	       ("selection_stat" "'if'" "'('" "exp" "')'" "stat")
	       ("selection_stat" "'if'" "'('" "exp" "')'" "stat" "'else'" "stat")
	       ("selection_stat" "'switch'" "'('" "exp" "')'" "stat")
	       ("iteration_stat" "'while'" "'('" "exp" "')'" "stat")
	       ("iteration_stat" "'do'" "stat" "'while'" "'('" "exp" "')'" "';'")
	       ("iteration_stat" "'for'" "'('" "exp" "';'" "exp" "';'" "exp" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "exp" "';'" "exp" "';'" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "exp" "';'" "';'" "exp" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "exp" "';'" "';'" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "';'" "exp" "';'" "exp" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "';'" "exp" "';'" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "';'" "';'" "exp" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "';'" "';'" "')'" "stat")
	       ("jump_stat" "'goto'" "id" "';'")
	       ("jump_stat" "'continue'" "';'")
	       ("jump_stat" "'break'" "';'")
	       ("jump_stat" "'return'" "exp" "';'")
	       ("jump_stat" "'return'" "';'")
	       ("exp" "assignment_exp")
	       ("exp" "exp" "','" "assignment_exp")
	       ("assignment_exp" "conditional_exp")
	       ("assignment_exp" "unary_exp" "assignment_operator" "assignment_exp")
	       ("assignment_operator" "'='")
	       ("assignment_operator" "'*='")
	       ("assignment_operator" "'/='")
	       ("assignment_operator" "'%='")
	       ("assignment_operator" "'+='")
	       ("assignment_operator" "'-='")
	       ("assignment_operator" "'\<\<='")
	       ("assignment_operator" "'\>\>='")
	       ("assignment_operator" "'&='")
	       ("assignment_operator" "'^='")
	       ("assignment_operator" "'|='")
	       ("conditional_exp" "logical_or_exp")
	       ("conditional_exp" "logical_or_exp" "'?'" "exp" "':'" "conditional_exp")
	       ("const_exp" "conditional_exp")
	       ("logical_or_exp" "logical_and_exp")
	       ("logical_or_exp" "logical_or_exp" "'||'" "logical_and_exp")
	       ("logical_and_exp" "inclusive_or_exp")
	       ("logical_and_exp" "logical_and_exp" "'&&'" "inclusive_or_exp")
	       ("inclusive_or_exp" "exclusive_or_exp")
	       ("inclusive_or_exp" "inclusive_or_exp" "'|'" "exclusive_or_exp")
	       ("exclusive_or_exp" "and_exp")
	       ("exclusive_or_exp" "exclusive_or_exp" "'^'" "and_exp")
	       ("and_exp" "equality_exp")
	       ("and_exp" "and_exp" "'&'" "equality_exp")
	       ("equality_exp" "relational_exp")
	       ("equality_exp" "equality_exp" "'=='" "relational_exp")
	       ("equality_exp" "equality_exp" "'!='" "relational_exp")
	       ("relational_exp" "shift_expression")
	       ("relational_exp" "relational_exp" "'\<'" "shift_expression")
	       ("relational_exp" "relational_exp" "'\>'" "shift_expression")
	       ("relational_exp" "relational_exp" "'\<='" "shift_expression")
	       ("relational_exp" "relational_exp" "'\>='" "shift_expression")
	       ("shift_expression" "additive_exp")
	       ("shift_expression" "shift_expression" "'\<\<'" "additive_exp")
	       ("shift_expression" "shift_expression" "'\>\>'" "additive_exp")
	       ("additive_exp" "mult_exp")
	       ("additive_exp" "additive_exp" "'+'" "mult_exp")
	       ("additive_exp" "additive_exp" "'-'" "mult_exp")
	       ("mult_exp" "cast_exp")
	       ("mult_exp" "mult_exp" "'*'" "cast_exp")
	       ("mult_exp" "mult_exp" "'/'" "cast_exp")
	       ("mult_exp" "mult_exp" "'%'" "cast_exp")
	       ("cast_exp" "unary_exp")
	       ("cast_exp" "'('" "type_name" "')'" "cast_exp")
	       ("unary_exp" "postfix_exp")
	       ("unary_exp" "'++'" "unary_exp")
	       ("unary_exp" "'--'" "unary_exp")
	       ("unary_exp" "unary_operator" "cast_exp")
	       ("unary_exp" "'sizeof'" "unary_exp")
	       ("unary_exp" "'sizeof'" "'('" "type_name" "')'")
	       ("unary_operator" "'&'")
	       ("unary_operator" "'*'")
	       ("unary_operator" "'+'")
	       ("unary_operator" "'-'")
	       ("unary_operator" "'~'")
	       ("unary_operator" "'!'")
	       ("postfix_exp" "primary_exp")
	       ("postfix_exp" "postfix_exp" "'['" "exp" "']'")
	       ("postfix_exp" "postfix_exp" "'('" "argument_exp_list" "')'")
	       ("postfix_exp" "postfix_exp" "'('" "')'")
	       ("postfix_exp" "postfix_exp" "'.'" "id")
	       ("postfix_exp" "postfix_exp" "'-\>'" "id")
	       ("postfix_exp" "postfix_exp" "'++'")
	       ("postfix_exp" "postfix_exp" "'--'")
	       ("primary_exp" "id")
	       ("primary_exp" "const")
	       ("primary_exp" "string")
	       ("primary_exp" "'('" "exp" "')'")
	       ("argument_exp_list" "assignment_exp")
	       ("argument_exp_list" "argument_exp_list" "','" "assignment_exp")
	       ("const" "int_const")
	       ("const" "char_const")
	       ("const" "float_const")
	       ("const" "enumeration_const")
	       )))

(defparameter *cbnf-min*
  (make-grammar "translation_unit"
	     '(("translation_unit" "external_decl")
	       ("translation_unit" "translation_unit" "external_decl")
	       ("external_decl" "function_definition")
	       ("external_decl" "decl")
	       ("function_definition" "decl_specs" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "decl_specs" "declarator" "compound_stat")
	       ("function_definition" "declarator" "compound_stat")
	       ("decl" "decl_specs" "init_declarator_list" "';'")
	       ("decl" "decl_specs" "';'")
	       ("decl_list" "decl")
	       ("decl_list" "decl_list" "decl")
	       ("storage_class_spec" "'auto'")
	       ("storage_class_spec" "'register'")
	       ("storage_class_spec" "'static'")
	       ("storage_class_spec" "'extern'")
	       ("storage_class_spec" "'typedef'")
	       ("type_qualifier" "'const'")
	       ("type_qualifier" "'volatile'")
	       ("struct_or_union_spec" "struct_or_union" "id" "'\{'" "struct_decl_list" "'\}'")
	       ("struct_or_union_spec" "struct_or_union" "'\{'" "struct_decl_list" "'\}'")
	       ("struct_or_union_spec" "struct_or_union" "id")
	       ("struct_or_union" "'struct'")
	       ("struct_or_union" "'union'")
	       ("struct_decl_list" "struct_decl")
	       ("struct_decl_list" "struct_decl_list" "struct_decl")
	       ("init_declarator_list" "init_declarator")
	       ("init_declarator_list" "init_declarator_list" "','" "init_declarator")
	       ("init_declarator" "declarator")
	       ("init_declarator" "declarator" "'='" "initializer")
	       ("struct_decl" "spec_qualifier_list" "struct_declarator_list" "';'")
	       ("spec_qualifier_list" "type_spec" "spec_qualifier_list")
	       ("spec_qualifier_list" "type_spec")
	       ("spec_qualifier_list" "type_qualifier" "spec_qualifier_list")
	       ("spec_qualifier_list" "type_qualifier")
	       ("struct_declarator_list" "struct_declarator")
	       ("struct_declarator_list" "struct_declarator_list" "','" "struct_declarator")
	       ("struct_declarator" "declarator")
	       ("struct_declarator" "declarator" "':'" "const_exp")
	       ("struct_declarator" "':'" "const_exp")
	       ("enum_spec" "'enum'" "id" "'\{'" "enumerator_list" "'\}'")
	       ("enum_spec" "'enum'" "'\{'" "enumerator_list" "'\}'")
	       ("enum_spec" "'enum'" "id")
	       ("enumerator_list" "enumerator")
	       ("enumerator_list" "enumerator_list" "','" "enumerator")
	       ("enumerator" "id")
	       ("enumerator" "id" "'='" "const_exp")
	       ("declarator" "pointer" "direct_declarator")
	       ("declarator" "direct_declarator")
	       ("pointer" "'*'" "type_qualifier_list")
	       ("pointer" "'*'")
	       ("pointer" "'*'" "type_qualifier_list" "pointer")
	       ("pointer" "'*'" "pointer")
	       ("type_qualifier_list" "type_qualifier")
	       ("type_qualifier_list" "type_qualifier_list" "type_qualifier")
	       ("param_type_list" "param_list")
	       ("param_type_list" "param_list" "','" "'...'")
	       ("param_list" "param_decl")
	       ("param_list" "param_list" "','" "param_decl")
	       ("param_decl" "decl_specs" "declarator")
	       ("param_decl" "decl_specs" "abstract_declarator")
	       ("param_decl" "decl_specs")
	       ("id_list" "id")
	       ("id_list" "id_list" "','" "id")
	       ("initializer_list" "initializer")
	       ("initializer_list" "initializer_list" "','" "initializer")
	       ("type_name" "spec_qualifier_list" "abstract_declarator")
	       ("type_name" "spec_qualifier_list")
	       ("abstract_declarator" "pointer")
	       ("abstract_declarator" "pointer" "direct_abstract_declarator")
	       ("abstract_declarator" "direct_abstract_declarator")
	       ("typedef_name" "id")
	       ("stat" "labeled_stat")
	       ("stat" "exp_stat")
	       ("stat" "compound_stat")
	       ("stat" "selection_stat")
	       ("stat" "iteration_stat")
	       ("stat" "jump_stat")
	       ("labeled_stat" "id" "':'" "stat")
	       ("labeled_stat" "'case'" "const_exp" "':'" "stat")
	       ("labeled_stat" "'default'" "':'" "stat")
	       ("exp_stat" "exp" "';'")
	       ("exp_stat" "';'")
	       ("compound_stat" "'\{'" "decl_list" "stat_list" "'\}'")
	       ("compound_stat" "'\{'" "stat_list" "'\}'")
	       ("compound_stat" "'\{'" "decl_list" "'\}'")
	       ("compound_stat" "'\{'" "'\}'")
	       ("stat_list" "stat")
	       ("stat_list" "stat_list" "stat")
	       ("jump_stat" "'goto'" "id" "';'")
	       ("jump_stat" "'continue'" "';'")
	       ("jump_stat" "'break'" "';'")
	       ("jump_stat" "'return'" "exp" "';'")
	       ("jump_stat" "'return'" "';'")
	       ("exp" "assignment_exp")
	       ("exp" "exp" "','" "assignment_exp")
	       ("assignment_exp" "conditional_exp")
	       ("assignment_exp" "unary_exp" "assignment_operator" "assignment_exp")
	       ("conditional_exp" "logical_or_exp")
	       ("conditional_exp" "logical_or_exp" "'?'" "exp" "':'" "conditional_exp")
	       ("const_exp" "conditional_exp")
	       ("equality_exp" "relational_exp")
	       ("equality_exp" "equality_exp" "'=='" "relational_exp")
	       ("equality_exp" "equality_exp" "'!='" "relational_exp")
	       ("shift_expression" "additive_exp")
	       ("shift_expression" "shift_expression" "'\<\<'" "additive_exp")
	       ("shift_expression" "shift_expression" "'\>\>'" "additive_exp")
	       ("additive_exp" "mult_exp")
	       ("additive_exp" "additive_exp" "'+'" "mult_exp")
	       ("additive_exp" "additive_exp" "'-'" "mult_exp")
	       ("mult_exp" "cast_exp")
	       ("mult_exp" "mult_exp" "'*'" "cast_exp")
	       ("mult_exp" "mult_exp" "'/'" "cast_exp")
	       ("mult_exp" "mult_exp" "'%'" "cast_exp")
	       ("cast_exp" "unary_exp")
	       ("cast_exp" "'('" "type_name" "')'" "cast_exp")
	       ("argument_exp_list" "assignment_exp")
	       ("argument_exp_list" "argument_exp_list" "','" "assignment_exp")
	       )))

(defparameter *cbnf-petit*
  (make-grammar "translation_unit"
	     '(("translation_unit" "external_decl")
	       ("translation_unit" "translation_unit" "external_decl")
	       ("external_decl" "function_definition")
	       ("external_decl" "decl")
	       ("function_definition" "decl_specs" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "decl_specs" "declarator" "compound_stat")
	       ("function_definition" "declarator" "compound_stat")
	       ("decl" "decl_specs" "init_declarator_list" "';'")
	       ("decl" "decl_specs" "';'")
	       ("init_declarator_list" "init_declarator")
	       ("init_declarator_list" "init_declarator_list" "','" "init_declarator")
	       ("init_declarator" "declarator")
	       ("init_declarator" "declarator" "'='" "initializer")
	       ("struct_decl" "spec_qualifier_list" "struct_declarator_list" "';'")
	       ("struct_declarator_list" "struct_declarator")
	       ("struct_declarator_list" "struct_declarator_list" "','" "struct_declarator")
	       ("struct_declarator" "declarator")
	       ("struct_declarator" "declarator" "':'" "const_exp")
	       ("struct_declarator" "':'" "const_exp")
	       ("declarator" "pointer" "direct_declarator")
	       ("declarator" "direct_declarator")
	       ("pointer" "'*'" "type_qualifier_list")
	       ("pointer" "'*'")
	       ("pointer" "'*'" "type_qualifier_list" "pointer")
	       ("pointer" "'*'" "pointer")
	       ("type_qualifier_list" "type_qualifier")
	       ("type_qualifier_list" "type_qualifier_list" "type_qualifier")
	       ("param_type_list" "param_list")
	       ("param_type_list" "param_list" "','" "'...'")
	       ("param_list" "param_decl")
	       ("param_list" "param_list" "','" "param_decl")
	       ("param_decl" "decl_specs" "declarator")
	       ("param_decl" "decl_specs" "abstract_declarator")
	       ("param_decl" "decl_specs")
	       ("id_list" "id")
	       ("id_list" "id_list" "','" "id")
	       ("initializer_list" "initializer")
	       ("initializer_list" "initializer_list" "','" "initializer")
	       ("type_name" "spec_qualifier_list" "abstract_declarator")
	       ("type_name" "spec_qualifier_list")
	       ("typedef_name" "id")
	       ("labeled_stat" "id" "':'" "stat")
	       ("labeled_stat" "'case'" "const_exp" "':'" "stat")
	       ("labeled_stat" "'default'" "':'" "stat")
	       )))



(defparameter *cbnf-alist*
  '(("const" ("enumeration_const") ("float_const") ("char_const")
     ("int_const"))
    ("argument_exp_list" ("argument_exp_list" "','" "assignment_exp")
     ("assignment_exp"))
    ("primary_exp" ("'('" "exp" "')'") ("string") ("const") ("id"))
    ("postfix_exp" ("postfix_exp" "'--'") ("postfix_exp" "'++'")
     ("postfix_exp" "'->'" "id") ("postfix_exp" "'.'" "id")
     ("postfix_exp" "'('" "')'")
     ("postfix_exp" "'('" "argument_exp_list" "')'")
     ("postfix_exp" "'['" "exp" "']'") ("primary_exp"))
    ("unary_operator" ("'!'") ("'~'") ("'-'") ("'+'") ("'*'") ("'&'"))
    ("unary_exp" ("'sizeof'" "'('" "type_name" "')'")
     ("'sizeof'" "unary_exp") ("unary_operator" "cast_exp")
     ("'--'" "unary_exp") ("'++'" "unary_exp") ("postfix_exp"))
    ("cast_exp" ("'('" "type_name" "')'" "cast_exp") ("unary_exp"))
    ("mult_exp" ("mult_exp" "'%'" "cast_exp")
     ("mult_exp" "'/'" "cast_exp") ("mult_exp" "'*'" "cast_exp")
     ("cast_exp"))
    ("additive_exp" ("additive_exp" "'-'" "mult_exp")
     ("additive_exp" "'+'" "mult_exp") ("mult_exp"))
    ("shift_expression" ("shift_expression" "'>>'" "additive_exp")
     ("shift_expression" "'<<'" "additive_exp") ("additive_exp"))
    ("relational_exp" ("relational_exp" "'>='" "shift_expression")
     ("relational_exp" "'<='" "shift_expression")
     ("relational_exp" "'>'" "shift_expression")
     ("relational_exp" "'<'" "shift_expression") ("shift_expression"))
    ("equality_exp" ("equality_exp" "'!='" "relational_exp")
     ("equality_exp" "'=='" "relational_exp") ("relational_exp"))
    ("and_exp" ("and_exp" "'&'" "equality_exp") ("equality_exp"))
    ("exclusive_or_exp" ("exclusive_or_exp" "'^'" "and_exp") ("and_exp"))
    ("inclusive_or_exp" ("inclusive_or_exp" "'|'" "exclusive_or_exp")
     ("exclusive_or_exp"))
    ("logical_and_exp" ("logical_and_exp" "'&&'" "inclusive_or_exp")
     ("inclusive_or_exp"))
    ("logical_or_exp" ("logical_or_exp" "'||'" "logical_and_exp")
     ("logical_and_exp"))
    ("const_exp" ("conditional_exp"))
    ("conditional_exp"
     ("logical_or_exp" "'?'" "exp" "':'" "conditional_exp")
     ("logical_or_exp"))
    ("assignment_operator" ("'|='") ("'^='") ("'&='") ("'>>='") ("'<<='")
     ("'-='") ("'+='") ("'%='") ("'/='") ("'*='") ("'='"))
    ("assignment_exp" ("unary_exp" "assignment_operator" "assignment_exp")
     ("conditional_exp"))
    ("exp" ("exp" "','" "assignment_exp") ("assignment_exp"))
    ("jump_stat" ("'return'" "';'") ("'return'" "exp" "';'")
     ("'break'" "';'") ("'continue'" "';'") ("'goto'" "id" "';'"))
    ("iteration_stat" ("'for'" "'('" "';'" "';'" "')'" "stat")
     ("'for'" "'('" "';'" "';'" "exp" "')'" "stat")
     ("'for'" "'('" "';'" "exp" "';'" "')'" "stat")
     ("'for'" "'('" "';'" "exp" "';'" "exp" "')'" "stat")
     ("'for'" "'('" "exp" "';'" "';'" "')'" "stat")
     ("'for'" "'('" "exp" "';'" "';'" "exp" "')'" "stat")
     ("'for'" "'('" "exp" "';'" "exp" "';'" "')'" "stat")
     ("'for'" "'('" "exp" "';'" "exp" "';'" "exp" "')'" "stat")
     ("'do'" "stat" "'while'" "'('" "exp" "')'" "';'")
     ("'while'" "'('" "exp" "')'" "stat"))
    ("selection_stat" ("'switch'" "'('" "exp" "')'" "stat")
     ("'if'" "'('" "exp" "')'" "stat" "'else'" "stat")
     ("'if'" "'('" "exp" "')'" "stat"))
    ("stat_list" ("stat_list" "stat") ("stat"))
    ("compound_stat" ("'{'" "'}'") ("'{'" "decl_list" "'}'")
     ("'{'" "stat_list" "'}'") ("'{'" "decl_list" "stat_list" "'}'"))
    ("exp_stat" ("';'") ("exp" "';'"))
    ("labeled_stat" ("'default'" "':'" "stat")
     ("'case'" "const_exp" "':'" "stat") ("id" "':'" "stat"))
    ("stat" ("jump_stat") ("iteration_stat") ("selection_stat")
     ("compound_stat") ("exp_stat") ("labeled_stat"))
    ("typedef_name" ("id"))
    ("direct_abstract_declarator" ("'('" "')'")
     ("direct_abstract_declarator" "'('" "')'")
     ("'('" "param_type_list" "')'")
     ("direct_abstract_declarator" "'('" "param_type_list" "')'")
     ("'['" "']'") ("direct_abstract_declarator" "'['" "']'")
     ("'['" "const_exp" "']'")
     ("direct_abstract_declarator" "'['" "const_exp" "']'")
     ("'('" "abstract_declarator" "')'"))
    ("abstract_declarator" ("direct_abstract_declarator")
     ("pointer" "direct_abstract_declarator") ("pointer"))
    ("type_name" ("spec_qualifier_list")
     ("spec_qualifier_list" "abstract_declarator"))
    ("initializer_list" ("initializer_list" "','" "initializer")
     ("initializer"))
    ("initializer" ("'{'" "initializer_list" "','" "'}'")
     ("'{'" "initializer_list" "'}'") ("assignment_exp"))
    ("id_list" ("id_list" "','" "id") ("id"))
    ("param_decl" ("decl_specs") ("decl_specs" "abstract_declarator")
     ("decl_specs" "declarator"))
    ("param_list" ("param_list" "','" "param_decl") ("param_decl"))
    ("param_type_list" ("param_list" "','" "'...'") ("param_list"))
    ("type_qualifier_list" ("type_qualifier_list" "type_qualifier")
     ("type_qualifier"))
    ("pointer" ("'*'" "pointer") ("'*'" "type_qualifier_list" "pointer")
     ("'*'") ("'*'" "type_qualifier_list"))
    ("direct_declarator" ("direct_declarator" "'('" "')'")
     ("direct_declarator" "'('" "id_list" "')'")
     ("direct_declarator" "'('" "param_type_list" "')'")
     ("direct_declarator" "'['" "']'")
     ("direct_declarator" "'['" "const_exp" "']'")
     ("'('" "declarator" "')'") ("id"))
    ("declarator" ("direct_declarator") ("pointer" "direct_declarator"))
    ("enumerator" ("id" "'='" "const_exp") ("id"))
    ("enumerator_list" ("enumerator_list" "','" "enumerator")
     ("enumerator"))
    ("enum_spec" ("'enum'" "id") ("'enum'" "'{'" "enumerator_list" "'}'")
     ("'enum'" "id" "'{'" "enumerator_list" "'}'"))
    ("struct_declarator" ("':'" "const_exp")
     ("declarator" "':'" "const_exp") ("declarator"))
    ("struct_declarator_list"
     ("struct_declarator_list" "','" "struct_declarator")
     ("struct_declarator"))
    ("spec_qualifier_list" ("type_qualifier")
     ("type_qualifier" "spec_qualifier_list") ("type_spec")
     ("type_spec" "spec_qualifier_list"))
    ("struct_decl" ("spec_qualifier_list" "struct_declarator_list" "';'"))
    ("init_declarator" ("declarator" "'='" "initializer") ("declarator"))
    ("init_declarator_list"
     ("init_declarator_list" "','" "init_declarator") ("init_declarator"))
    ("struct_decl_list" ("struct_decl_list" "struct_decl")
     ("struct_decl"))
    ("struct_or_union" ("'union'") ("'struct'"))
    ("struct_or_union_spec" ("struct_or_union" "id")
     ("struct_or_union" "'{'" "struct_decl_list" "'}'")
     ("struct_or_union" "id" "'{'" "struct_decl_list" "'}'"))
    ("type_qualifier" ("'volatile'") ("'const'"))
    ("type_spec" ("typedef_name") ("enum_spec") ("struct_or_union_spec")
     ("'unsigned'") ("'signed'") ("'double'") ("'float'") ("'long'")
     ("'int'") ("'short'") ("'char'") ("'void'"))
    ("storage_class_spec" ("'typedef'") ("'extern'") ("'static'")
     ("'register'") ("'auto'"))
    ("decl_specs" ("type_qualifier") ("type_qualifier" "decl_specs")
     ("type_spec") ("type_spec" "decl_specs") ("storage_class_spec")
     ("storage_class_spec" "decl_specs"))
    ("decl_list" ("decl_list" "decl") ("decl"))
    ("decl" ("decl_specs" "';'")
     ("decl_specs" "init_declarator_list" "';'"))
    ("function_definition" ("declarator" "compound_stat")
     ("decl_specs" "declarator" "compound_stat")
     ("declarator" "decl_list" "compound_stat")
     ("decl_specs" "declarator" "decl_list" "compound_stat"))
    ("external_decl" ("decl") ("function_definition"))
    ("translation_unit" ("translation_unit" "external_decl")
     ("external_decl"))))


(defparameter *cbnf-symbol-alist*
  '((|const| (|enumeration_const|) (|float_const|) (|char_const|)
     (|int_const|))
    (|argument_exp_list| (|argument_exp_list| |','| |assignment_exp|)
     (|assignment_exp|))
    (|primary_exp| (|'('| |exp| |')'|) (|string|) (|const|) (|id|))
    (|postfix_exp| (|postfix_exp| |'--'|) (|postfix_exp| |'++'|)
     (|postfix_exp| |'->'| |id|) (|postfix_exp| |'.'| |id|)
     (|postfix_exp| |'('| |')'|)
     (|postfix_exp| |'('| |argument_exp_list| |')'|)
     (|postfix_exp| |'['| |exp| |']'|) (|primary_exp|))
    (|unary_operator| (|'!'|) (|'~'|) (|'-'|) (|'+'|) (|'*'|) (|'&'|))
    (|unary_exp| (|'sizeof'| |'('| |type_name| |')'|)
     (|'sizeof'| |unary_exp|) (|unary_operator| |cast_exp|)
     (|'--'| |unary_exp|) (|'++'| |unary_exp|) (|postfix_exp|))
    (|cast_exp| (|'('| |type_name| |')'| |cast_exp|) (|unary_exp|))
    (|mult_exp| (|mult_exp| |'%'| |cast_exp|)
     (|mult_exp| |'/'| |cast_exp|) (|mult_exp| |'*'| |cast_exp|)
     (|cast_exp|))
    (|additive_exp| (|additive_exp| |'-'| |mult_exp|)
     (|additive_exp| |'+'| |mult_exp|) (|mult_exp|))
    (|shift_expression| (|shift_expression| |'>>'| |additive_exp|)
     (|shift_expression| |'<<'| |additive_exp|) (|additive_exp|))
    (|relational_exp| (|relational_exp| |'>='| |shift_expression|)
     (|relational_exp| |'<='| |shift_expression|)
     (|relational_exp| |'>'| |shift_expression|)
     (|relational_exp| |'<'| |shift_expression|) (|shift_expression|))
    (|equality_exp| (|equality_exp| |'!='| |relational_exp|)
     (|equality_exp| |'=='| |relational_exp|) (|relational_exp|))
    (|and_exp| (|and_exp| |'&'| |equality_exp|) (|equality_exp|))
    (|exclusive_or_exp| (|exclusive_or_exp| |'^'| |and_exp|) (|and_exp|))
    (|inclusive_or_exp| (|inclusive_or_exp| |'\|'| |exclusive_or_exp|)
     (|exclusive_or_exp|))
    (|logical_and_exp| (|logical_and_exp| |'&&'| |inclusive_or_exp|)
     (|inclusive_or_exp|))
    (|logical_or_exp| (|logical_or_exp| |'\|\|'| |logical_and_exp|)
     (|logical_and_exp|))
    (|const_exp| (|conditional_exp|))
    (|conditional_exp|
     (|logical_or_exp| |'?'| |exp| |':'| |conditional_exp|)
     (|logical_or_exp|))
    (|assignment_operator| (|'\|='|) (|'^='|) (|'&='|) (|'>>='|) (|'<<='|)
     (|'-='|) (|'+='|) (|'%='|) (|'/='|) (|'*='|) (|'='|))
    (|assignment_exp| (|unary_exp| |assignment_operator| |assignment_exp|)
     (|conditional_exp|))
    (|exp| (|exp| |','| |assignment_exp|) (|assignment_exp|))
    (|jump_stat| (|'return'| |';'|) (|'return'| |exp| |';'|)
     (|'break'| |';'|) (|'continue'| |';'|) (|'goto'| |id| |';'|))
    (|iteration_stat| (|'for'| |'('| |';'| |';'| |')'| |stat|)
     (|'for'| |'('| |';'| |';'| |exp| |')'| |stat|)
     (|'for'| |'('| |';'| |exp| |';'| |')'| |stat|)
     (|'for'| |'('| |';'| |exp| |';'| |exp| |')'| |stat|)
     (|'for'| |'('| |exp| |';'| |';'| |')'| |stat|)
     (|'for'| |'('| |exp| |';'| |';'| |exp| |')'| |stat|)
     (|'for'| |'('| |exp| |';'| |exp| |';'| |')'| |stat|)
     (|'for'| |'('| |exp| |';'| |exp| |';'| |exp| |')'| |stat|)
     (|'do'| |stat| |'while'| |'('| |exp| |')'| |';'|)
     (|'while'| |'('| |exp| |')'| |stat|))
    (|selection_stat| (|'switch'| |'('| |exp| |')'| |stat|)
     (|'if'| |'('| |exp| |')'| |stat| |'else'| |stat|)
     (|'if'| |'('| |exp| |')'| |stat|))
    (|stat_list| (|stat_list| |stat|) (|stat|))
    (|compound_stat| (|'{'| |'}'|) (|'{'| |decl_list| |'}'|)
     (|'{'| |stat_list| |'}'|) (|'{'| |decl_list| |stat_list| |'}'|))
    (|exp_stat| (|';'|) (|exp| |';'|))
    (|labeled_stat| (|'default'| |':'| |stat|)
     (|'case'| |const_exp| |':'| |stat|) (|id| |':'| |stat|))
    (|stat| (|jump_stat|) (|iteration_stat|) (|selection_stat|)
     (|compound_stat|) (|exp_stat|) (|labeled_stat|))
    (|typedef_name| (|id|))
    (|direct_abstract_declarator| (|'('| |')'|)
     (|direct_abstract_declarator| |'('| |')'|)
     (|'('| |param_type_list| |')'|)
     (|direct_abstract_declarator| |'('| |param_type_list| |')'|)
     (|'['| |']'|) (|direct_abstract_declarator| |'['| |']'|)
     (|'['| |const_exp| |']'|)
     (|direct_abstract_declarator| |'['| |const_exp| |']'|)
     (|'('| |abstract_declarator| |')'|))
    (|abstract_declarator| (|direct_abstract_declarator|)
     (|pointer| |direct_abstract_declarator|) (|pointer|))
    (|type_name| (|spec_qualifier_list|)
     (|spec_qualifier_list| |abstract_declarator|))
    (|initializer_list| (|initializer_list| |','| |initializer|)
     (|initializer|))
    (|initializer| (|'{'| |initializer_list| |','| |'}'|)
     (|'{'| |initializer_list| |'}'|) (|assignment_exp|))
    (|id_list| (|id_list| |','| |id|) (|id|))
    (|param_decl| (|decl_specs|) (|decl_specs| |abstract_declarator|)
     (|decl_specs| |declarator|))
    (|param_list| (|param_list| |','| |param_decl|) (|param_decl|))
    (|param_type_list| (|param_list| |','| |'...'|) (|param_list|))
    (|type_qualifier_list| (|type_qualifier_list| |type_qualifier|)
     (|type_qualifier|))
    (|pointer| (|'*'| |pointer|) (|'*'| |type_qualifier_list| |pointer|)
     (|'*'|) (|'*'| |type_qualifier_list|))
    (|direct_declarator| (|direct_declarator| |'('| |')'|)
     (|direct_declarator| |'('| |id_list| |')'|)
     (|direct_declarator| |'('| |param_type_list| |')'|)
     (|direct_declarator| |'['| |']'|)
     (|direct_declarator| |'['| |const_exp| |']'|)
     (|'('| |declarator| |')'|) (|id|))
    (|declarator| (|direct_declarator|) (|pointer| |direct_declarator|))
    (|enumerator| (|id| |'='| |const_exp|) (|id|))
    (|enumerator_list| (|enumerator_list| |','| |enumerator|)
     (|enumerator|))
    (|enum_spec| (|'enum'| |id|) (|'enum'| |'{'| |enumerator_list| |'}'|)
     (|'enum'| |id| |'{'| |enumerator_list| |'}'|))
    (|struct_declarator| (|':'| |const_exp|)
     (|declarator| |':'| |const_exp|) (|declarator|))
    (|struct_declarator_list|
     (|struct_declarator_list| |','| |struct_declarator|)
     (|struct_declarator|))
    (|spec_qualifier_list| (|type_qualifier|)
     (|type_qualifier| |spec_qualifier_list|) (|type_spec|)
     (|type_spec| |spec_qualifier_list|))
    (|struct_decl| (|spec_qualifier_list| |struct_declarator_list| |';'|))
    (|init_declarator| (|declarator| |'='| |initializer|) (|declarator|))
    (|init_declarator_list|
     (|init_declarator_list| |','| |init_declarator|) (|init_declarator|))
    (|struct_decl_list| (|struct_decl_list| |struct_decl|)
     (|struct_decl|))
    (|struct_or_union| (|'union'|) (|'struct'|))
    (|struct_or_union_spec| (|struct_or_union| |id|)
     (|struct_or_union| |'{'| |struct_decl_list| |'}'|)
     (|struct_or_union| |id| |'{'| |struct_decl_list| |'}'|))
    (|type_qualifier| (|'volatile'|) (|'const'|))
    (|type_spec| (|typedef_name|) (|enum_spec|) (|struct_or_union_spec|)
     (|'unsigned'|) (|'signed'|) (|'double'|) (|'float'|) (|'long'|)
     (|'int'|) (|'short'|) (|'char'|) (|'void'|))
    (|storage_class_spec| (|'typedef'|) (|'extern'|) (|'static'|)
     (|'register'|) (|'auto'|))
    (|decl_specs| (|type_qualifier|) (|type_qualifier| |decl_specs|)
     (|type_spec|) (|type_spec| |decl_specs|) (|storage_class_spec|)
     (|storage_class_spec| |decl_specs|))
    (|decl_list| (|decl_list| |decl|) (|decl|))
    (|decl| (|decl_specs| |';'|)
     (|decl_specs| |init_declarator_list| |';'|))
    (|function_definition| (|declarator| |compound_stat|)
     (|decl_specs| |declarator| |compound_stat|)
     (|declarator| |decl_list| |compound_stat|)
     (|decl_specs| |declarator| |decl_list| |compound_stat|))
    (|external_decl| (|decl|) (|function_definition|))
    (|translation_unit| (|translation_unit| |external_decl|)
     (|external_decl|))))


(defparameter *cbnf-symbol*
  '((|translation_unit| |external_decl|)
    (|translation_unit| |translation_unit| |external_decl|)
    (|external_decl| |function_definition|) (|external_decl| |decl|)
    (|function_definition| |decl_specs| |declarator| |decl_list|
     |compound_stat|)
    (|function_definition| |declarator| |decl_list| |compound_stat|)
    (|function_definition| |decl_specs| |declarator| |compound_stat|)
    (|function_definition| |declarator| |compound_stat|)
    (|decl| |decl_specs| |init_declarator_list| |';'|)
    (|decl| |decl_specs| |';'|) (|decl_list| |decl|)
    (|decl_list| |decl_list| |decl|)
    (|decl_specs| |storage_class_spec| |decl_specs|)
    (|decl_specs| |storage_class_spec|)
    (|decl_specs| |type_spec| |decl_specs|) (|decl_specs| |type_spec|)
    (|decl_specs| |type_qualifier| |decl_specs|)
    (|decl_specs| |type_qualifier|) (|storage_class_spec| |'auto'|)
    (|storage_class_spec| |'register'|) (|storage_class_spec| |'static'|)
    (|storage_class_spec| |'extern'|) (|storage_class_spec| |'typedef'|)
    (|type_spec| |'void'|) (|type_spec| |'char'|) (|type_spec| |'short'|)
    (|type_spec| |'int'|) (|type_spec| |'long'|) (|type_spec| |'float'|)
    (|type_spec| |'double'|) (|type_spec| |'signed'|)
    (|type_spec| |'unsigned'|) (|type_spec| |struct_or_union_spec|)
    (|type_spec| |enum_spec|) (|type_spec| |typedef_name|)
    (|type_qualifier| |'const'|) (|type_qualifier| |'volatile'|)
    (|struct_or_union_spec| |struct_or_union| |id| |'{'|
     |struct_decl_list| |'}'|)
    (|struct_or_union_spec| |struct_or_union| |'{'| |struct_decl_list|
     |'}'|)
    (|struct_or_union_spec| |struct_or_union| |id|)
    (|struct_or_union| |'struct'|) (|struct_or_union| |'union'|)
    (|struct_decl_list| |struct_decl|)
    (|struct_decl_list| |struct_decl_list| |struct_decl|)
    (|init_declarator_list| |init_declarator|)
    (|init_declarator_list| |init_declarator_list| |','|
     |init_declarator|)
    (|init_declarator| |declarator|)
    (|init_declarator| |declarator| |'='| |initializer|)
    (|struct_decl| |spec_qualifier_list| |struct_declarator_list| |';'|)
    (|spec_qualifier_list| |type_spec| |spec_qualifier_list|)
    (|spec_qualifier_list| |type_spec|)
    (|spec_qualifier_list| |type_qualifier| |spec_qualifier_list|)
    (|spec_qualifier_list| |type_qualifier|)
    (|struct_declarator_list| |struct_declarator|)
    (|struct_declarator_list| |struct_declarator_list| |','|
     |struct_declarator|)
    (|struct_declarator| |declarator|)
    (|struct_declarator| |declarator| |':'| |const_exp|)
    (|struct_declarator| |':'| |const_exp|)
    (|enum_spec| |'enum'| |id| |'{'| |enumerator_list| |'}'|)
    (|enum_spec| |'enum'| |'{'| |enumerator_list| |'}'|)
    (|enum_spec| |'enum'| |id|) (|enumerator_list| |enumerator|)
    (|enumerator_list| |enumerator_list| |','| |enumerator|)
    (|enumerator| |id|) (|enumerator| |id| |'='| |const_exp|)
    (|declarator| |pointer| |direct_declarator|)
    (|declarator| |direct_declarator|) (|direct_declarator| |id|)
    (|direct_declarator| |'('| |declarator| |')'|)
    (|direct_declarator| |direct_declarator| |'['| |const_exp| |']'|)
    (|direct_declarator| |direct_declarator| |'['| |']'|)
    (|direct_declarator| |direct_declarator| |'('| |param_type_list|
     |')'|)
    (|direct_declarator| |direct_declarator| |'('| |id_list| |')'|)
    (|direct_declarator| |direct_declarator| |'('| |')'|)
    (|pointer| |'*'| |type_qualifier_list|) (|pointer| |'*'|)
    (|pointer| |'*'| |type_qualifier_list| |pointer|)
    (|pointer| |'*'| |pointer|) (|type_qualifier_list| |type_qualifier|)
    (|type_qualifier_list| |type_qualifier_list| |type_qualifier|)
    (|param_type_list| |param_list|)
    (|param_type_list| |param_list| |','| |'...'|)
    (|param_list| |param_decl|)
    (|param_list| |param_list| |','| |param_decl|)
    (|param_decl| |decl_specs| |declarator|)
    (|param_decl| |decl_specs| |abstract_declarator|)
    (|param_decl| |decl_specs|) (|id_list| |id|)
    (|id_list| |id_list| |','| |id|) (|initializer| |assignment_exp|)
    (|initializer| |'{'| |initializer_list| |'}'|)
    (|initializer| |'{'| |initializer_list| |','| |'}'|)
    (|initializer_list| |initializer|)
    (|initializer_list| |initializer_list| |','| |initializer|)
    (|type_name| |spec_qualifier_list| |abstract_declarator|)
    (|type_name| |spec_qualifier_list|) (|abstract_declarator| |pointer|)
    (|abstract_declarator| |pointer| |direct_abstract_declarator|)
    (|abstract_declarator| |direct_abstract_declarator|)
    (|direct_abstract_declarator| |'('| |abstract_declarator| |')'|)
    (|direct_abstract_declarator| |direct_abstract_declarator| |'['|
     |const_exp| |']'|)
    (|direct_abstract_declarator| |'['| |const_exp| |']'|)
    (|direct_abstract_declarator| |direct_abstract_declarator| |'['|
     |']'|)
    (|direct_abstract_declarator| |'['| |']'|)
    (|direct_abstract_declarator| |direct_abstract_declarator| |'('|
     |param_type_list| |')'|)
    (|direct_abstract_declarator| |'('| |param_type_list| |')'|)
    (|direct_abstract_declarator| |direct_abstract_declarator| |'('|
     |')'|)
    (|direct_abstract_declarator| |'('| |')'|) (|typedef_name| |id|)
    (|stat| |labeled_stat|) (|stat| |exp_stat|) (|stat| |compound_stat|)
    (|stat| |selection_stat|) (|stat| |iteration_stat|)
    (|stat| |jump_stat|) (|labeled_stat| |id| |':'| |stat|)
    (|labeled_stat| |'case'| |const_exp| |':'| |stat|)
    (|labeled_stat| |'default'| |':'| |stat|) (|exp_stat| |exp| |';'|)
    (|exp_stat| |';'|)
    (|compound_stat| |'{'| |decl_list| |stat_list| |'}'|)
    (|compound_stat| |'{'| |stat_list| |'}'|)
    (|compound_stat| |'{'| |decl_list| |'}'|)
    (|compound_stat| |'{'| |'}'|) (|stat_list| |stat|)
    (|stat_list| |stat_list| |stat|)
    (|selection_stat| |'if'| |'('| |exp| |')'| |stat|)
    (|selection_stat| |'if'| |'('| |exp| |')'| |stat| |'else'| |stat|)
    (|selection_stat| |'switch'| |'('| |exp| |')'| |stat|)
    (|iteration_stat| |'while'| |'('| |exp| |')'| |stat|)
    (|iteration_stat| |'do'| |stat| |'while'| |'('| |exp| |')'| |';'|)
    (|iteration_stat| |'for'| |'('| |exp| |';'| |exp| |';'| |exp| |')'|
     |stat|)
    (|iteration_stat| |'for'| |'('| |exp| |';'| |exp| |';'| |')'| |stat|)
    (|iteration_stat| |'for'| |'('| |exp| |';'| |';'| |exp| |')'| |stat|)
    (|iteration_stat| |'for'| |'('| |exp| |';'| |';'| |')'| |stat|)
    (|iteration_stat| |'for'| |'('| |';'| |exp| |';'| |exp| |')'| |stat|)
    (|iteration_stat| |'for'| |'('| |';'| |exp| |';'| |')'| |stat|)
    (|iteration_stat| |'for'| |'('| |';'| |';'| |exp| |')'| |stat|)
    (|iteration_stat| |'for'| |'('| |';'| |';'| |')'| |stat|)
    (|jump_stat| |'goto'| |id| |';'|) (|jump_stat| |'continue'| |';'|)
    (|jump_stat| |'break'| |';'|) (|jump_stat| |'return'| |exp| |';'|)
    (|jump_stat| |'return'| |';'|) (|exp| |assignment_exp|)
    (|exp| |exp| |','| |assignment_exp|)
    (|assignment_exp| |conditional_exp|)
    (|assignment_exp| |unary_exp| |assignment_operator| |assignment_exp|)
    (|assignment_operator| |'='|) (|assignment_operator| |'*='|)
    (|assignment_operator| |'/='|) (|assignment_operator| |'%='|)
    (|assignment_operator| |'+='|) (|assignment_operator| |'-='|)
    (|assignment_operator| |'<<='|) (|assignment_operator| |'>>='|)
    (|assignment_operator| |'&='|) (|assignment_operator| |'^='|)
    (|assignment_operator| |'\|='|) (|conditional_exp| |logical_or_exp|)
    (|conditional_exp| |logical_or_exp| |'?'| |exp| |':'|
     |conditional_exp|)
    (|const_exp| |conditional_exp|) (|logical_or_exp| |logical_and_exp|)
    (|logical_or_exp| |logical_or_exp| |'\|\|'| |logical_and_exp|)
    (|logical_and_exp| |inclusive_or_exp|)
    (|logical_and_exp| |logical_and_exp| |'&&'| |inclusive_or_exp|)
    (|inclusive_or_exp| |exclusive_or_exp|)
    (|inclusive_or_exp| |inclusive_or_exp| |'\|'| |exclusive_or_exp|)
    (|exclusive_or_exp| |and_exp|)
    (|exclusive_or_exp| |exclusive_or_exp| |'^'| |and_exp|)
    (|and_exp| |equality_exp|) (|and_exp| |and_exp| |'&'| |equality_exp|)
    (|equality_exp| |relational_exp|)
    (|equality_exp| |equality_exp| |'=='| |relational_exp|)
    (|equality_exp| |equality_exp| |'!='| |relational_exp|)
    (|relational_exp| |shift_expression|)
    (|relational_exp| |relational_exp| |'<'| |shift_expression|)
    (|relational_exp| |relational_exp| |'>'| |shift_expression|)
    (|relational_exp| |relational_exp| |'<='| |shift_expression|)
    (|relational_exp| |relational_exp| |'>='| |shift_expression|)
    (|shift_expression| |additive_exp|)
    (|shift_expression| |shift_expression| |'<<'| |additive_exp|)
    (|shift_expression| |shift_expression| |'>>'| |additive_exp|)
    (|additive_exp| |mult_exp|)
    (|additive_exp| |additive_exp| |'+'| |mult_exp|)
    (|additive_exp| |additive_exp| |'-'| |mult_exp|)
    (|mult_exp| |cast_exp|) (|mult_exp| |mult_exp| |'*'| |cast_exp|)
    (|mult_exp| |mult_exp| |'/'| |cast_exp|)
    (|mult_exp| |mult_exp| |'%'| |cast_exp|) (|cast_exp| |unary_exp|)
    (|cast_exp| |'('| |type_name| |')'| |cast_exp|)
    (|unary_exp| |postfix_exp|) (|unary_exp| |'++'| |unary_exp|)
    (|unary_exp| |'--'| |unary_exp|)
    (|unary_exp| |unary_operator| |cast_exp|)
    (|unary_exp| |'sizeof'| |unary_exp|)
    (|unary_exp| |'sizeof'| |'('| |type_name| |')'|)
    (|unary_operator| |'&'|) (|unary_operator| |'*'|)
    (|unary_operator| |'+'|) (|unary_operator| |'-'|)
    (|unary_operator| |'~'|) (|unary_operator| |'!'|)
    (|postfix_exp| |primary_exp|)
    (|postfix_exp| |postfix_exp| |'['| |exp| |']'|)
    (|postfix_exp| |postfix_exp| |'('| |argument_exp_list| |')'|)
    (|postfix_exp| |postfix_exp| |'('| |')'|)
    (|postfix_exp| |postfix_exp| |'.'| |id|)
    (|postfix_exp| |postfix_exp| |'->'| |id|)
    (|postfix_exp| |postfix_exp| |'++'|)
    (|postfix_exp| |postfix_exp| |'--'|) (|primary_exp| |id|)
    (|primary_exp| |const|) (|primary_exp| |string|)
    (|primary_exp| |'('| |exp| |')'|)
    (|argument_exp_list| |assignment_exp|)
    (|argument_exp_list| |argument_exp_list| |','| |assignment_exp|)
    (|const| |int_const|) (|const| |char_const|) (|const| |float_const|)
    (|const| |enumeration_const|)))
