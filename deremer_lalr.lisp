;; ================================================================
;; 
;;   Modular LALR(1) Parser Generotor Engine by DeRemer's method
;; 
;; ================================================================


(defstruct (grammar (:constructor mkgrammar (start rules)))
  start rules)

;; 
(defun indexing-grammar (grammar)
  (let* ((ntset (remove-duplicates (mapcar #'car (grammar-rules grammar)) :test #'equal))
	 (tset (set-difference (remove-duplicates (apply #'append (mapcar #'cdr (grammar-rules grammar))) :test #'equal) ntset :test #'equal))
	 (symbol-alist nil)
	 (nt-num 1)
	 (t-num 0))
    ;; numbering to non-terminal symbol
    (loop for symbol in ntset
	  do (push (cons symbol nt-num) symbol-alist)
	     (incf nt-num))
    (setf t-num nt-num)
    ;; numbering to terminal symbol
    (loop for symbol in tset
	  do (push (cons symbol t-num) symbol-alist)
	     (incf t-num))
    ;; make symbol-array 
    (let ((symbol-array (make-array (+ t-num 1) :initial-element nil)))
      (dolist (sym-num symbol-alist)
	(setf (aref symbol-array (cdr sym-num)) (car sym-num))))
    ;; replace symbol to index
    (mkgrammar
     (cdr (assoc (grammar-start grammar) symbol-alist :test #'equal))
     (mapcar #'(lambda (rule) (mapcar #'(lambda (x) (cdr (assoc x symbol-alist :test #'equal))) rule)) (grammar-rules grammar)))))

(defun rule-lhs (rule) (car rule))
(defun rule-rhs (rule) (cdr rule))

(defun foldl (e op l)
  (if l (foldl (funcall op e (first l)) op (rest l)) e))
	
(defun all-symbols (g)
  (foldl () #'(lambda (syms rule) (union syms rule)) (grammar-rules g)))

(defun non-terminal-symbols (g)
  (remove-duplicates (mapcar #'rule-lhs (grammar-rules g)) :test #'equal))

(defun terminal-symbols (g)
  (set-difference (all-symbols g) (non-terminal-symbols g)))

;; Grammar with Non-Terminal Symbols and Terminal Symbols Set.
(defun enrich-grammar (g)
  (let ((ntset (non-terminal-symbols g)))
    (list (grammar-start g) (grammar-rules g) ntset
	  (set-difference (all-symbols g) ntset))))

(defun eg-start (eg) (first eg))
(defun eg-rules (eg) (second eg))
(defun eg-ntset (eg) (third eg))
(defun eg-tset (eg) (fourth eg))

;; for list
(defun take (n l)
  (if (< 0 n) (cons (first l) (take (- n 1) (rest l))) nil))
      
(defun drop (n l)
  (if (< 0 n) (drop (- n 1) (rest l)) l))


;; nullability-checker
(defun nullablity (eg)
  (let ((nullable nil)
	(changed t))
    ;; initialize
    (dolist (symb (eg-ntset eg)) (push (cons symb nil) nullable))
    (dolist (symb (eg-tset eg)) (push (cons symb nil) nullable))
    (loop while changed
	  do (setf changed nil)
	     (dolist (rule (eg-rules eg))
	       (when (or (null (rule-rhs rule)) ; X -> 
			 (every #'(lambda (symb) (cdr (assoceq symb nullable))) (rule-rhs rule))) ; X -> Y_1 .. Y_n s.t. all Y_i is nullable.
		 ;; only false -> true
		 (unless (cdr (assoceq (rule-lhs rule) nullable))
		   (setf (cdr (assoceq (rule-lhs rule) nullable)) t
			 changed t)))))
    nullable))

(defun sequence-nullability (nullable-list sequence)
  (let ((nullable t))
    (loop while nullable
	  for s in sequence
	  do (setf nullable (cdr (assoceq s nullable-list))))
    nullable))

;; assoc using equal
(defun assoceq (item alist)
  (assoc item alist :test #'equal))

;; 
(defun first-symbols (eg)
  (let ((firsts nil)
	(terminal-symbols (eg-tset eg))
	(non-terminal-symbols (eg-ntset eg))
	(changed t))
    ;; for terminals
    (dolist (symbol terminal-symbols) (push (cons symbol (list symbol)) firsts))
    ;; initialize for non-terminals
    (dolist (symbol non-terminal-symbols) (push (cons symbol nil) firsts))
    (loop while changed
	  do (setf changed nil)
	     (dolist (X non-terminal-symbols)
	       (let ((old-x-firsts (copy-list (cdr (assoceq X firsts)))))
		 ;; all [X -> Y_1 .. Y_n]s
		 (dolist (rule (remove-if-not #'(lambda (rule) (equal X (rule-lhs rule))) (eg-rules eg)))
		   (let ((all-null t))
		     (loop while all-null
			   for Y in (rule-rhs rule)
			   do (let ((y-firsts (cdr (assoceq Y firsts)))
				    (null-exists nil))
				(dolist (symbol y-firsts)
				  (if symbol
				      (pushnew symbol (cdr (assoceq X firsts)) :test #'equal)
				      (setf null-exists t)))
				;; if nil isn't in y-firsts, we don't have to look rest [Y_i]s.
				(unless null-exists (setf all-null nil))))
		     ;; n = 0 or all Y_i's firsts has nil.
		     (when all-null
		       (pushnew nil (cdr (assoceq X firsts)) :test #'equal))))
		 (unless (set-eq old-x-firsts (cdr (assoceq X firsts)))
		   (setf changed t)))))
    firsts))
		     
(defun sequence-first-symbols (firsts sequence)
  (let ((result nil)
	(has-null t))
    (loop while has-null
	  for X in sequence
	  do (if (assoceq X firsts)
		 (let ((X-firsts (cdr (assoceq X firsts))))
		   (unless (member () X-firsts) (setf has-null nil))
		   (setf result (union result X-firsts)))
		 (progn (push X result) (setf has-null nil))))
    result))


(defun set-eq (s1 s2)
  (null (set-exclusive-or s1 s2 :test #'equal)))

;; 
(defun follow-symbols (eg &key eof)
  (let ((follows (list (cons (eg-start eg) eof)))
	(firsts (first-symbols eg))
	(ntset (eg-ntset eg))
	(changed t))
    (dolist (symbol ntset) (push (cons symbol nil) follows))
    (loop while changed
	  do (setf changed nil)
	     (dolist (rule (eg-rules eg))
	       (let ((A (rule-lhs rule)))
		 (labels ((f (symbol-list)
			    (let ((B (first symbol-list)))
			      (when (member B ntset :test #'equal)
				(let ((rest-firsts (sequence-first-symbols firsts (rest symbol-list))))
				  ;; [ A -> aB ] or [ A -> aBb /\ () in First(b) ]
				  (when (or (null rest-firsts) (member nil rest-firsts :test #'equal))
				    (dolist (symbol (cdr (assoceq A follows)))
				      (unless (member symbol (cdr (assoceq B follows)) :test #'equal)
					(push symbol (cdr (assoceq B follows)))
					(setf changed t))))
				  (dolist (symbol rest-firsts)
				    (unless (or (null symbol) (member symbol (cdr (assoceq B follows)) :test #'equal))
				      (push symbol (cdr (assoceq B follows)))
				      (setf changed t))))))))
		   (maplist #'f (rule-rhs rule))))))
    follows))
  

;; --------------------------------
;;  LR parser
;; 

;; lr-item
(defun item-lhs (item) (first item))
(defun item-rhs-pre (item) (second item))
(defun item-rhs-suc (item) (third item))
(defun shift-item (item)
  (when (item-rhs-suc item)
    (list (item-lhs item)
	  (append (item-rhs-pre item) (list (first (item-rhs-suc item))))
	  (rest (item-rhs-suc item)))))

;; closure for lr(0)-item
(defun lr0-closure (eg state)
  (let ((ntset (copy-list (eg-ntset eg)))
	(rules (eg-rules eg))
	(looked-symbols nil)
	(changed t))
    (loop while changed
	  do (setf changed nil)
	     (dolist (item state)
	       (let ((X (first (item-rhs-suc item))))
		 (when (and X
			    (not (member X looked-symbols :test #'equal))
			    (member X  ntset :test #'equal))
		   ;; (when (delete X ntset :test #'equal)
		     (push X looked-symbols)
		     (setf changed t)
		     (dolist (rule (remove-if-not #'(lambda (rule) (equal (rule-lhs rule) X)) rules))
		       (push (list (rule-lhs rule) () (rule-rhs rule)) state))))))
    state))

;; lr0-goto
(defun lr0-goto (eg state symbol)
  (let ((base-items (remove-if-not
		     #'(lambda (item) (equal symbol (first (item-rhs-suc item))))
		     state)))
    (lr0-closure eg (mapcar #'shift-item base-items))))

;; make lr0-parse table
(defun lr0-parse-table (eg &key start eof)
  (let* ((init (lr0-closure eg (list (list start () (list (eg-start eg) eof)))))
	 (num 0)
	 (state-num-list (list (cons init num)))
	 (goto-table (list (cons num nil)))
	 (all-symbol (append (eg-ntset eg) (eg-tset eg) (list eof)))
	 (changed t))
    (loop while changed
	  do (setf changed nil)
	     (dolist (state-num state-num-list)
	       (let ((I (car state-num)) (n (cdr state-num)))
		 (dolist (X all-symbol)
		   (let ((next-state (lr0-goto eg I X)))
		     (when next-state
		       (let ((next-num (cdr (assoceq next-state state-num-list))))
			 (unless next-num
			   (incf num)
			   (setf next-num num)
			   (push (cons next-state next-num) state-num-list)
			   (push (cons next-num nil) goto-table))
			 (unless (member (cons X next-num) (cdr (assoceq n goto-table)) :test #'equal)
			   (push (cons X next-num) (cdr (assoceq n goto-table)))
			   (setf changed t)))))))))
    (cons state-num-list goto-table)))



(defun dr-set (eg goto-table)
  (let ((ntset (eg-ntset eg))
	(dr nil))
    (dolist (row goto-table dr)
      (dolist (arrow (cdr row))
	(destructuring-bind (symbol . num) arrow
	  (when (member symbol ntset :test #'equal)
	    (push (cons (cons (car row) symbol)
			(mapcar #'car (remove-if #'(lambda (arrow) (member (car arrow) ntset :test #'equal)) (cdr (assoc num goto-table)))))
		  dr)))))))

(defun rel-reads (eg parse-table)
  (let ((ntset (eg-ntset eg))
	(nullable (nullablity eg))
	(state-num-list (car parse-table))
	(goto-table (cdr parse-table))
	(result nil))
    (dolist (state-num state-num-list) 	; (I . n)
      (dolist (symbol ntset)		; X
	(let ((next (cdr (assoceq symbol (cdr (assoceq (cdr state-num) goto-table)))))) ; I -X-> ..
	  (when next
	    (push (cons (cons (cdr state-num) symbol)
			(mapcar #'(lambda (x) (cons next (car x)))
				(remove-if-not #'(lambda (arrow) (cdr (assoceq (car arrow) nullable))) (cdr (assoceq next goto-table)))))
		  result)))))
    result))

;; algorithm; Digraph
(defun alg-digraph (node-list rel base-f)
  (let ((result-f nil)
	(stack nil)
	(depth 0)
	(nar (make-hash-table :test #'equal)))
    (dolist (node node-list) (push (cons node nil) result-f))
    (labels ((traverse (x)
	       (push x stack)
	       (incf depth)
	       (setf (gethash x nar) depth)
	       (setf (cdr (assoceq x result-f)) (cdr (assoceq x base-f)))
	       (dolist (y (cdr (assoceq x rel)))
		 (when (= 0 (gethash y nar 0)) (traverse y))
		 (setf (gethash x nar) (min (gethash x nar 0) (gethash y nar 0)))
		 (setf (cdr (assoceq x result-f)) (union (cdr (assoceq x result-f)) (cdr (assoceq y result-f)))))
	       (when (= depth (gethash x nar 0))
		 (loop do (setf (gethash (first stack) nar) most-positive-fixnum)
		       until (equal x (pop stack))))))
      (dolist (node node-list result-f)
	(when (= 0 (gethash node nar 0)) (traverse node))))))

(defun detect-loop (rel x &key (visited nil) (test #'eql))
  ;; (format t "[~a,~a,~a,~a]~%" rel x visited test)
  (let ((found nil))
    (loop until found
	  for s in (cdr (assoc x rel :test test))
	  do (if (member x visited :test test)
		 (setf found t)
		 (setf found (detect-loop rel s :visited (cons x visited) :test test))))
    found))
  

(defun transitions (goto-table)
  (let ((node-list nil))
    (dolist (row goto-table node-list)
      (setf node-list
	    (append (mapcar #'(lambda (arrow) (cons (car row) (car arrow))) (cdr row)) node-list)))))

;; Read(p,A)
(defun make-read (eg parse-table)
  (let* ((dr (dr-set eg (cdr parse-table)))
	 (rel (rel-reads eg parse-table))
	 (ntset (eg-ntset eg))
	 (nt-transitions (remove-if-not #'(lambda (transition) (member (cdr transition) ntset :test #'equal))
					(transitions (cdr parse-table)))))
    ;; making node-list
    (alg-digraph nt-transitions rel dr)))

(defun rev-traverse (goto-table starts sequence)
  (if sequence
      (let ((preds
	      (mapcar #'car
		      (remove-if-not
		       #'(lambda (row)
			   (intersection (mapcar #'(lambda (x) (cons (first sequence) x)) starts)
					 (cdr row) :test #'equal))
		       goto-table))))
	(rev-traverse goto-table preds (rest sequence)))
      starts))



(defun rel-includes (eg parse-table)
  (let* ((rules (eg-rules eg))
	 (ntset (eg-ntset eg))
	 (nullable-list (nullablity eg))
	 (nt-transitions (remove-if-not #'(lambda (transition) (member (cdr transition) ntset :test #'equal))
					(transitions (cdr parse-table))))
	 (result nil))
    (dolist (transition nt-transitions)	; transition = (p, A)
      (dolist (rule rules)		; rule = X -> aYb
	(let ((rhs (copy-list (rule-rhs rule)))
	      (pre nil))
	  (loop while rhs
		do (when (and (equal (first rhs) (cdr transition))
			      (sequence-nullability nullable-list (rest rhs)))
		     (let* ((starts (rev-traverse (cdr parse-table) (list (car transition)) pre))
			    (available (intersection (mapcar #'(lambda (x) (cons x (rule-lhs rule))) starts)
						     nt-transitions
						     :test #'equal)))
		       (if (assoceq (cons (car transition) (first rhs)) result)
			   (setf (cdr (assoceq transition result))
				 (union available (cdr (assoceq transition result))))
			   (push (cons transition available) result))))
		   (push (pop rhs) pre)))))
    result))

(defun make-follow (eg parse-table )
  (let* ((reads (make-read eg parse-table))
	 (rel (rel-includes eg parse-table))
	 (ntset (eg-ntset eg))
	 (nt-transitions (remove-if-not #'(lambda (transition) (member (cdr transition) ntset :test #'equal))
					(transitions (cdr parse-table)))))
    (alg-digraph nt-transitions rel reads)))


(defun rel-lookback (parse-table)
  (let ((result nil))
    (dolist (state-num (car parse-table))
      (dolist (item (remove-if-not #'(lambda (item) (null (item-rhs-suc item))) (car state-num)))
	(let ((ps (rev-traverse (cdr parse-table) (list (cdr state-num)) (reverse (item-rhs-pre item)))))
	  (when ps (push (cons (cons (cdr state-num) (cons (item-lhs item) (item-rhs-pre item))) (mapcar #'(lambda (p) (cons p (item-lhs item))) ps)) result)))))
    result))

(defun make-laset (eg parse-table)
  (let ((follows (make-follow eg parse-table))
	(rel (rel-lookback parse-table))
	(result nil))
    (dolist (lb rel result)
      (push (cons (car lb)
		  (remove-duplicates
		   (apply #'append (mapcar #'(lambda (transition) (cdr (assoceq transition follows))) (cdr lb)))
		   :test #'equal)) result))))


(defun lalr1-parse-table (eg &key start eof)
  (let* ((lr0-pt (lr0-parse-table eg :start start :eof eof))
	 (lasets (make-laset eg lr0-pt))
	 (new-state-list nil))
    (dolist (state-num (car lr0-pt))
      (push (cons (mapcar #'(lambda (item)
			      (destructuring-bind (lhs pre suc) item
				(cons item (and (null suc) (cdr (assoceq (cons (cdr state-num) (cons lhs pre)) lasets))))))
			  (car state-num))
		  (cdr state-num))
	    new-state-list))
    (cons new-state-list (cdr lr0-pt))))


(defun lalr1-action-table (eg &key start eof)
  (let ((parse-table (lalr1-parse-table eg :start start :eof eof))
	(action-table nil)
	(tset (eg-tset eg))
	(error-info nil))
    (dolist (state-num (car parse-table))
      (push (cons (cdr state-num) nil) action-table))
    (dolist (row (cdr parse-table))
      (setf (cdr (assoceq (car row) action-table)) (cdr row)))
    (loop until error-info
	  for (state . num) in (car parse-table)
	  do  (when (member (cons (list start (list (eg-start eg)) (list eof)) nil) state :test #'equal)
		(push (cons eof nil) (cdr (assoceq num action-table))))
	     (dolist (lalr1-item state)
	       (if (item-rhs-suc (car lalr1-item))
		   (let ((a (first (item-rhs-suc (car lalr1-item)))))
		     (when (and (member a tset :test #'equal)
				(assoceq a (cdr (assoceq num (cdr parse-table)))))
		       (if (and (assoceq a (cdr (assoceq num action-table)))
				(not (member (assoceq a (cdr (assoceq num (cdr parse-table)))) (cdr (assoceq num action-table)) :test #'equal)))
			   (progn (setf error-info "duplicate action at shift")
				  (return))
			   (push (assoceq a (cdr (assoceq num (cdr parse-table))))
				 (cdr (assoceq num action-table))))))
		   (unless (equal start (item-lhs (car lalr1-item)))
		     (dolist (la (cdr lalr1-item))
		       (if (and (assoceq la (cdr (assoceq num action-table)))
				(not (member (cons la (cons (item-lhs (car lalr1-item))
						(item-rhs-pre (car lalr1-item)))) (cdr (assoceq num action-table)) :test #'equal)))
			   (progn (setf error-info "duplicate action at reduce")
				  (return))
			   (push (cons la (cons (item-lhs (car lalr1-item))
						(item-rhs-pre (car lalr1-item))))
				 (cdr (assoceq num action-table)))))))))
    (or error-info
	action-table)))
												    

(defun gen-parse (table-gen eg tokens &key start eof (dump nil))
  (let ((ptable (funcall table-gen eg :start start :eof eof))
	(stack (list 0)))
    (setf tokens (append tokens (list eof)))
    (loop
      do (unless tokens (format t "error!") (return nil))
	 (let* ((acts (cdr (assoc (car stack) ptable)))
		(act (assoceq (car tokens) acts)))
	   (unless act (format t "error: [~a,~a]" stack tokens) (return nil))
	   (cond ((null (cdr act))
		  (when dump
		    (format t "~a~%" (append (reverse (remove-if #'numberp stack)) tokens)))
		  (format t "accept~%")
		  (return t))
		 ((listp (cdr act))
		  (when dump
		    (format t "~a~%" (append (reverse (remove-if #'numberp stack)) tokens)))
		  (let ((rule (cdr act)))
		    (dotimes (n (length (rule-rhs rule)))
		      (setf stack (cddr stack)))
		    (let ((next (cdr (assoceq (rule-lhs rule) (cdr (assoceq (car stack) ptable))))))
		      (push (rule-lhs rule) stack)
		      (push next stack))))
		    ;; (format t "~a~%" stack)
		 ((numberp (cdr act))
		  (push (pop tokens) stack)
		  (push (cdr act) stack))
		  ;; (format t "~a~%" stack)
		 (t (format t "irregular") (return nil)))))))  

;; 
;; by Dragon book
;; 

(defun make-kernels (items start)
  (remove-if-not #'(lambda (item) (or (equal start (item-lhs item)) (item-rhs-pre item))) items))

(defun lr1-closure (eg lrset)
  (let ((tmplrset lrset)		; J = I
	(ntset (eg-ntset eg)) ; V_n
	(fs (first-symbols eg))
	(changed t))
    (loop
      while changed
      do (setf changed nil)
	 (dolist (lr1-item tmplrset)
	   ;; (format t "~a~%" tmplrset)
	   ;; (format t "~a~%" lr1-item)
	   (let ((symb (first (item-rhs-suc (car lr1-item))))
		 (suffix (rest (item-rhs-suc (car lr1-item)))))
	     (when (member symb ntset :test #'equal)
	       ;; (format t "true~%")
	       (dolist (rule (remove-if-not #'(lambda (rule) (equal (rule-lhs rule) symb)) (eg-rules eg)))
		 ;; (format t "{~a},~a~%" rule lr1-item)
		 (let ((lookaheads (cdr lr1-item)))
		   (if lookaheads
		       (dolist (lookahead lookaheads)
			 ;; (format t "[~{~a~}~a]~%" suffix lookahead)
			 (dolist (b (sequence-first-symbols fs (append suffix (list lookahead))))
			   ;; (format t ">~a~%" b)
			   (let ((lr1-newitem (cons (list (rule-lhs rule) '() (rule-rhs rule)) (list b))))
			     ;; (format t ":: ~a~%" lr1-newitem)
			     (unless (member lr1-newitem tmplrset :test #'equal)
			       (push lr1-newitem tmplrset)
			       (setf changed t)))))
		       (dolist (b (sequence-first-symbols fs suffix))
			 ;; (format t ">~a~%" b)
			 (let ((lr1-newitem (cons (list (rule-lhs rule) '() (rule-rhs rule)) (list b))))
			   ;; (format t ":: ~a~%" lr1-newitem)
			   (unless (member lr1-newitem tmplrset :test #'equal)
			     (push lr1-newitem tmplrset)
			     (setf changed t))))
		       )))))))
    tmplrset))

(defun lr1-goto (eg lrset symb)
  (let ((items (remove-if-not
		#'(lambda (lr1-item) (equal symb (first (item-rhs-suc (car lr1-item)))))
		lrset)))
  (lr1-closure eg (mapcar 
		    #'(lambda (lr1-item)
			(cons
			 (list (item-lhs (car lr1-item))
			       (append (item-rhs-pre (car lr1-item)) (list (first (item-rhs-suc (car lr1-item)))))
			       (rest (item-rhs-suc (car lr1-item))))
			 (cdr lr1-item)))
		    items))))

(defun determine-lookaheads
    (eg kernels num symbol goto ht-from ht-spon pr-symbol)
  ;; (format t "[~a,~a,~a]~%" kernels num symbol)
  (let ((result nil))
    (dolist (item kernels result)
      (let ((j (lr1-closure eg (list (cons item (list pr-symbol)))))
	    (tmp nil))
	;; (format t "~a~%" j)
	(dolist (lr1-item j)
	  (when (equal symbol (first (item-rhs-suc (car lr1-item))))
	    (let ((to-num (cdr (assoc symbol (cdr (assoceq num goto)))))
		  (to-item (shift-item (car lr1-item))))
	      (if (member pr-symbol (cdr lr1-item) :test #'equal)
		  (progn
		    (push (list 'propagate to-num to-item) tmp)
		    (push (cons num item)
			  (gethash (cons to-num to-item) ht-from)))
		  (progn
		    (push (list 'spontaneously (cons num item) to-num to-item (cdr lr1-item)) tmp)
		    (setf
		     (gethash (cons to-num to-item) ht-spon)
		     (union (cdr lr1-item) (gethash (cons to-num to-item) ht-spon))))))))
	(when tmp (push tmp result))
	))))

(defun make-lalr1-items
    (eg &key (start (gensym)) (eof (gensym)))
  (let* (
	 ;; step 1 and 2
	 (all-items (lr0-parse-table eg :start start :eof eof))
	 ;; step 3
	 (all-kernels 
	   (mapcar #'(lambda (x)
		       (cons (make-kernels (car x) start) (cdr x)))
		   (car all-items)))
	 (result nil)
	 (all-lalr1-kernels nil)
	 ;; (not-in-symbol (gensym))
	 (ht-from (make-hash-table :test #'equal))
	 (ht-spon (make-hash-table :test #'equal)))
    ;; step 4
    (setf (gethash
    	   (cons 0 (list start () (list (eg-start eg) eof)))
    	   ht-spon)
	  nil)
    (dolist (kernels-and-num all-kernels)
      (let ((kernels (car kernels-and-num))
	    (num (cdr kernels-and-num))
	    (tmp nil))
	(dolist (symb (append (eg-ntset eg) (eg-tset eg)))
	  (let ((dl (determine-lookaheads eg kernels num symb (cdr all-items) ht-from ht-spon "#")))
	    (when dl (push dl tmp))))
	(when tmp (push (cons kernels tmp) result))))
    ;; (format t "~a~%" result)
    ;; step 5.
    (let ((ht-lookaheads (make-hash-table :test #'equal)))
      ;; spontaneously lookaheads
      (dolist (kernels-and-num all-kernels)
	(let ((kernels (car kernels-and-num))
	      (num (cdr kernels-and-num)))
	  (dolist (kern kernels)
	    (setf (gethash (cons num kern) ht-lookaheads)
		  (gethash (cons num kern) ht-spon)))))
      ;; lookaheads' propagation
      (let ((changed t))
	(loop
	  while changed
	  do (setf changed nil)
	     (dolist (kernels-and-num all-kernels)
	       (let* ((kernels (car kernels-and-num))
		      (num (cdr kernels-and-num)))
		 (dolist (kernel kernels)
		   (let ((old (copy-list (gethash (cons num kernel) ht-lookaheads))))
		     (dolist (from (remove-if #'(lambda (x) (equal (cons num kernel) x)) (gethash (cons num kernel) ht-from)))
		       (setf (gethash (cons num kernel) ht-lookaheads)
			     (union (gethash (cons num kernel) ht-lookaheads)
				    (gethash from ht-lookaheads)
				    :test #'equal)))
		     (unless (set-eq old (gethash (cons num kernel) ht-lookaheads))
		       (setf changed t))))))))
     ;; make lalr1-kernels
      ;; (format t "******~%")
      ;; (format t "~a~%" all-kernels)
      ;; (format t "******~%")
      (dolist (kernels-and-num all-kernels all-lalr1-kernels)
	(let ((kernels (car kernels-and-num))
	      (num (cdr kernels-and-num))
	      (lalr1-kernels nil))
	  (dolist (kernel kernels)
	    (push (cons kernel (gethash (cons num kernel) ht-lookaheads)) lalr1-kernels))
	  (push (cons lalr1-kernels num) all-lalr1-kernels)))
      ;; step 6. from kernel to state
      ;; (format t "~a~%" all-lalr1-kernels)
      (let ((l (mapcar
		#'(lambda (x)
		    (cons 
		     (lalr1-state-compress (lr1-closure eg (car x)))
		     (cdr x)))
		all-lalr1-kernels)))
	(values (cons l (cdr all-items)) start eof)))))

(defun lalr1-state-compress (state)
  (sort
   (foldl '()
	  #'(lambda (items item)
	      (if items
		  (let ((sep-ls (separate
				 #'(lambda (x) (equal (car item) (car x)))
				 items)))
		    (cons (cons (car item)
				(union (cdr item) (cdaar sep-ls)))
			  (cdr sep-ls)))
		  (list item)))
	  state)
   #'(lambda (x y) (string< (caar x) (caar y))))
  )

(defun separate (predicate list &key (key #'identity))
  (labels ((f (x y)
	     (if (funcall predicate (funcall key y))
		 (cons (cons y (car x)) (cdr x))
		 (cons (car x) (cons y (cdr x))))))
    (foldl (cons () ()) #'f list)))



;; 
;; checker
(defun lalr-checker (grammar start eof)
  (let ((l nil)
	(r nil))
    (loop for x in (mapcar #'(lambda (items) (mapcar #'(lambda (item) (if (item-rhs-suc (car item)) (cons (car item) nil) item)) items)) (mapcar #'car (sort (car (make-lalr1-items (enrich-grammar grammar) :start start :eof eof)) #'< :key #'cdr)))
	  for y in (mapcar #'car (sort (car (lalr1-parse-table (enrich-grammar grammar) :start start :eof eof)) #'< :key #'cdr))
	  do (destructuring-bind (xl . xr) (separate #'(lambda (x) (cdr x)) x)
	       (destructuring-bind (yl . yr) (separate #'(lambda (x) (cdr x)) y)
		 (push (cons xl yl) l) (push (cons xr yr) r))))
    (cons
     (mapcar #'(lambda (x) (cons (equal (caar x) (cadr x)) (set-eq (cdar x) (cddr x))))
		    (mapcar #'(lambda (p) (cons (caar p) (cadr p))) l))
	    (mapcar #'(lambda (p) (set-eq (car p) (cdr p))) r))))






;; print
(defun print-goto (goto-table stream)
  (mapc #'(lambda (x)
	    (let ((num (car x)) (to (cdr x)))
	      (dolist (y to)
		(format stream "~a --~a-> ~a~%" num (car y) (cdr y))))) goto-table) nil)


(defun print-lalr1-item (item sep stream)
  (let ((lr-item (car item))
	(lasets (cdr item)))
    (format stream "[~a\\ -\\>\\ ~{~a\\ ~}~a~{\\ ~a~}\\ ,\\ ~{~a~^\\~}]"
	    (item-lhs lr-item) (item-rhs-pre lr-item) sep (item-rhs-suc lr-item) lasets)))

(defun print-lalr1-parse-table (pt sep stream)
  (format stream "digraph lalr1_automaton {~%  graph [rankdir = LR];~%")
  (dolist (state-num (car pt))
    (format stream
	    "  ~a [shape=record, label=\"{~a|{~{~a\\l~}}}\"];~%"
	    (cdr state-num) (cdr state-num) (mapcar #'(lambda (item) (print-lalr1-item item sep nil)) (car state-num))))
  (dolist (row (cdr pt))
    (dolist (to (cdr row))
      (format stream "  ~a -> ~a [label=\"~a\"];~%" (car row) (cdr to) (car to))))
  (format stream "}~%"))

(defun dot-lalr1-automaton (grammar fname &key start eof sep)
  (with-open-file (s (concatenate 'string fname ".dot")
		     :direction :output
		     :if-exists :rename-and-delete :if-does-not-exist :create
		     :external-format :utf-8)
    (let ((pt (lalr1-parse-table (enrich-grammar grammar) :start start :eof eof)))
      (print-lalr1-parse-table pt sep s))))

;; 
;; for test
;; 

(defun separate-by (l predicate)
  (let ((result nil)
	(input (copy-list l))
	(tmp nil))
    (loop while input
	  do (if (funcall predicate (first input))
		 (progn
		   (push (reverse tmp) result)
		   (setf tmp nil)
		   (pop input))
		 (push (pop input) tmp)))
    (reverse result)))

(defun separate-string-by (str separator &key (with nil))
  (let ((result nil)
	(len (- (length str) 1))
	(start 0)
	(end nil))
    (loop do (setf end (position-if #'(lambda (x) (member x separator :test #'char=)) str :start start))
	     (let ((sub (subseq str start end)))
	       (when (< 0 (length sub)) (push sub result)))
	     (when (and end with) (push (subseq str end (+ end 1)) result))
	     (setf start (when end (+ 1 end)))
	  while (and end (< end len)))
    (reverse result)))

(defun bnf->string (fname)
  (with-open-file (stream fname)
    (let ((rule nil))
      (loop for line = (read-line stream nil nil)
	    while line 
	    do (unless (or (= 0 (length line)) (char= #\% (elt line 0))) (setf rule (concatenate 'string rule line))))
      (setf rule (substitute #\Space #\Tab rule))
      (let ((pos (search "';'" rule)))
	(loop while pos
	      do (setf (subseq rule pos (+ pos 3)) "'@'")
		 (setf pos (search "';'" rule)))
	(mapcar #'(lambda (rule) (substitute #\; #\@ rule)) (separate-string-by rule '(#\;)))))))

(defun string->rule (str)
  (destructuring-bind (lhs . rules)
      (let ((pos (position #\: str)))
	(cons (subseq str 0 pos) (subseq str (+ pos 1) nil)))
    (mapcar #'(lambda (x) (cons (string-trim " " lhs) (separate-string-by (string-trim '(#\Space) x) '(#\Space))))
	    (separate-string-by rules '(#\|)))))

(defun string->rules (str)
  (destructuring-bind (lhs . rhses)
      (let ((pos (position #\: str)))
	(cons (subseq str 0 pos) (subseq str (+ pos 1) nil)))
    (mapcar #'(lambda (x) (cons (string-trim " " lhs) x))
	    (mapcar #'(lambda (x) (separate-string-by x '(#\Space))) (separate-string-by rhses '(#\|))))))

(defun with-escape (str)
  (concatenate 'string "\\\"" str "\\\""))



(defun add-escape (str seeds start)
  (let ((pos (position-if #'(lambda (x) (member x seeds :test #'char=)) str :start start)))
    (if pos
	(concatenate 'string (subseq str start pos) "\\" (add-escape str seeds pos))
	(subseq str start))))
  


;; grammar samples
(defparameter *g1*
  (mkgrammar "E"
             '(("E" "E" "+" "T") ("E" "T") ("T" "T" "*" "F") ("T" "F")
	       ("F" "(" "E" ")") ("F" "id")))) 
(defparameter *g2*
  (mkgrammar "S" '(("S" "id") ("S" "S" "," "id")))) 
(defparameter *g3*
  (mkgrammar "S" '(("S" "A") ("S" "S" "A")))) 
(defparameter *g4*
  (mkgrammar "S" '(("S" "A") ("S" "A" "S")))) 
(defparameter *g5*
  (mkgrammar "S" '(("S" "int" "L") ("L" "id") ("L" "L" "," "id")))) 
(defparameter *g6*
  (mkgrammar "S"
             '(("S" "L" "=" "R") ("S" "R") ("L" "*" "R") ("L" "id")
	       ("R" "L")))) 
(defparameter *g7*
  (mkgrammar "S" '(("S" "C" "C") ("C" "B" "C") ("C" "D")))) 
(defparameter *g8*
  (mkgrammar "S"
             '(("S" "L" "=" "E") ("L" "id") ("L" "R" "^" "id")
              ("E" "E" "+" "R") ("E" "R") ("E" "@" "L") ("R" "id")))) 
(defparameter *G9*
  (mkgrammar "A" '(("A" "b" "B") ("B" "c" "C") ("C" "d" "A") ("A" "a"))))
(defparameter *G10*
  (mkgrammar "A" '(("A" "B" "C" "D" "A") ("B") ("C") ("D") ("A" "X")))) 
(defparameter *g11*
  (mkgrammar "S" '(("S" "A" "B") ("A") ("B") ("A" "x"))))


(defparameter *cbnf*
  (mkgrammar "translation_unit"
	     '(("translation_unit" "external_decl")
	       ("translation_unit" "translation_unit" "external_decl")
	       ("external_decl" "function_definition")
	       ("external_decl" "decl")
	       ("function_definition" "decl_specs" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "decl_specs" "declarator" "compound_stat")
	       ("function_definition" "declarator" "compound_stat")
	       ("decl" "decl_specs" "init_declarator_list" "';'")
	       ("decl" "decl_specs" "';'")
	       ("decl_list" "decl")
	       ("decl_list" "decl_list" "decl")
	       ("decl_specs" "storage_class_spec" "decl_specs")
	       ("decl_specs" "storage_class_spec")
	       ("decl_specs" "type_spec" "decl_specs")
	       ("decl_specs" "type_spec")
	       ("decl_specs" "type_qualifier" "decl_specs")
	       ("decl_specs" "type_qualifier")
	       ("storage_class_spec" "'auto'")
	       ("storage_class_spec" "'register'")
	       ("storage_class_spec" "'static'")
	       ("storage_class_spec" "'extern'")
	       ("storage_class_spec" "'typedef'")
	       ("type_spec" "'void'")
	       ("type_spec" "'char'")
	       ("type_spec" "'short'")
	       ("type_spec" "'int'")
	       ("type_spec" "'long'")
	       ("type_spec" "'float'")
	       ("type_spec" "'double'")
	       ("type_spec" "'signed'")
	       ("type_spec" "'unsigned'")
	       ("type_spec" "struct_or_union_spec")
	       ("type_spec" "enum_spec")
	       ("type_spec" "typedef_name")
	       ("type_qualifier" "'const'")
	       ("type_qualifier" "'volatile'")
	       ("struct_or_union_spec" "struct_or_union" "id" "'\{'" "struct_decl_list" "'\}'")
	       ("struct_or_union_spec" "struct_or_union" "'\{'" "struct_decl_list" "'\}'")
	       ("struct_or_union_spec" "struct_or_union" "id")
	       ("struct_or_union" "'struct'")
	       ("struct_or_union" "'union'")
	       ("struct_decl_list" "struct_decl")
	       ("struct_decl_list" "struct_decl_list" "struct_decl")
	       ("init_declarator_list" "init_declarator")
	       ("init_declarator_list" "init_declarator_list" "','" "init_declarator")
	       ("init_declarator" "declarator")
	       ("init_declarator" "declarator" "'='" "initializer")
	       ("struct_decl" "spec_qualifier_list" "struct_declarator_list" "';'")
	       ("spec_qualifier_list" "type_spec" "spec_qualifier_list")
	       ("spec_qualifier_list" "type_spec")
	       ("spec_qualifier_list" "type_qualifier" "spec_qualifier_list")
	       ("spec_qualifier_list" "type_qualifier")
	       ("struct_declarator_list" "struct_declarator")
	       ("struct_declarator_list" "struct_declarator_list" "','" "struct_declarator")
	       ("struct_declarator" "declarator")
	       ("struct_declarator" "declarator" "':'" "const_exp")
	       ("struct_declarator" "':'" "const_exp")
	       ("enum_spec" "'enum'" "id" "'\{'" "enumerator_list" "'\}'")
	       ("enum_spec" "'enum'" "'\{'" "enumerator_list" "'\}'")
	       ("enum_spec" "'enum'" "id")
	       ("enumerator_list" "enumerator")
	       ("enumerator_list" "enumerator_list" "','" "enumerator")
	       ("enumerator" "id")
	       ("enumerator" "id" "'='" "const_exp")
	       ("declarator" "pointer" "direct_declarator")
	       ("declarator" "direct_declarator")
	       ("direct_declarator" "id")
	       ("direct_declarator" "'('" "declarator" "')'")
	       ("direct_declarator" "direct_declarator" "'['" "const_exp" "']'")
	       ("direct_declarator" "direct_declarator" "'['" "']'")
	       ("direct_declarator" "direct_declarator" "'('" "param_type_list" "')'")
	       ("direct_declarator" "direct_declarator" "'('" "id_list" "')'")
	       ("direct_declarator" "direct_declarator" "'('" "')'")
	       ("pointer" "'*'" "type_qualifier_list")
	       ("pointer" "'*'")
	       ("pointer" "'*'" "type_qualifier_list" "pointer")
	       ("pointer" "'*'" "pointer")
	       ("type_qualifier_list" "type_qualifier")
	       ("type_qualifier_list" "type_qualifier_list" "type_qualifier")
	       ("param_type_list" "param_list")
	       ("param_type_list" "param_list" "','" "'...'")
	       ("param_list" "param_decl")
	       ("param_list" "param_list" "','" "param_decl")
	       ("param_decl" "decl_specs" "declarator")
	       ("param_decl" "decl_specs" "abstract_declarator")
	       ("param_decl" "decl_specs")
	       ("id_list" "id")
	       ("id_list" "id_list" "','" "id")
	       ("initializer" "assignment_exp")
	       ("initializer" "'\{'" "initializer_list" "'\}'")
	       ("initializer" "'\{'" "initializer_list" "','" "'\}'")
	       ("initializer_list" "initializer")
	       ("initializer_list" "initializer_list" "','" "initializer")
	       ("type_name" "spec_qualifier_list" "abstract_declarator")
	       ("type_name" "spec_qualifier_list")
	       ("abstract_declarator" "pointer")
	       ("abstract_declarator" "pointer" "direct_abstract_declarator")
	       ("abstract_declarator" "direct_abstract_declarator")
	       ("direct_abstract_declarator" "'('" "abstract_declarator" "')'")
	       ("direct_abstract_declarator" "direct_abstract_declarator" "'['" "const_exp" "']'")
	       ("direct_abstract_declarator" "'['" "const_exp" "']'")
	       ("direct_abstract_declarator" "direct_abstract_declarator" "'['" "']'")
	       ("direct_abstract_declarator" "'['" "']'")
	       ("direct_abstract_declarator" "direct_abstract_declarator" "'('" "param_type_list" "')'")
	       ("direct_abstract_declarator" "'('" "param_type_list" "')'")
	       ("direct_abstract_declarator" "direct_abstract_declarator" "'('" "')'")
	       ("direct_abstract_declarator" "'('" "')'")
	       ("typedef_name" "id")
	       ("stat" "labeled_stat")
	       ("stat" "exp_stat")
	       ("stat" "compound_stat")
	       ("stat" "selection_stat")
	       ("stat" "iteration_stat")
	       ("stat" "jump_stat")
	       ("labeled_stat" "id" "':'" "stat")
	       ("labeled_stat" "'case'" "const_exp" "':'" "stat")
	       ("labeled_stat" "'default'" "':'" "stat")
	       ("exp_stat" "exp" "';'")
	       ("exp_stat" "';'")
	       ("compound_stat" "'\{'" "decl_list" "stat_list" "'\}'")
	       ("compound_stat" "'\{'" "stat_list" "'\}'")
	       ("compound_stat" "'\{'" "decl_list" "'\}'")
	       ("compound_stat" "'\{'" "'\}'")
	       ("stat_list" "stat")
	       ("stat_list" "stat_list" "stat")
	       ("selection_stat" "'if'" "'('" "exp" "')'" "stat")
	       ("selection_stat" "'if'" "'('" "exp" "')'" "stat" "'else'" "stat")
	       ("selection_stat" "'switch'" "'('" "exp" "')'" "stat")
	       ("iteration_stat" "'while'" "'('" "exp" "')'" "stat")
	       ("iteration_stat" "'do'" "stat" "'while'" "'('" "exp" "')'" "';'")
	       ("iteration_stat" "'for'" "'('" "exp" "';'" "exp" "';'" "exp" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "exp" "';'" "exp" "';'" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "exp" "';'" "';'" "exp" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "exp" "';'" "';'" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "';'" "exp" "';'" "exp" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "';'" "exp" "';'" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "';'" "';'" "exp" "')'" "stat")
	       ("iteration_stat" "'for'" "'('" "';'" "';'" "')'" "stat")
	       ("jump_stat" "'goto'" "id" "';'")
	       ("jump_stat" "'continue'" "';'")
	       ("jump_stat" "'break'" "';'")
	       ("jump_stat" "'return'" "exp" "';'")
	       ("jump_stat" "'return'" "';'")
	       ("exp" "assignment_exp")
	       ("exp" "exp" "','" "assignment_exp")
	       ("assignment_exp" "conditional_exp")
	       ("assignment_exp" "unary_exp" "assignment_operator" "assignment_exp")
	       ("assignment_operator" "'='")
	       ("assignment_operator" "'*='")
	       ("assignment_operator" "'/='")
	       ("assignment_operator" "'%='")
	       ("assignment_operator" "'+='")
	       ("assignment_operator" "'-='")
	       ("assignment_operator" "'\<\<='")
	       ("assignment_operator" "'\>\>='")
	       ("assignment_operator" "'&='")
	       ("assignment_operator" "'^='")
	       ("assignment_operator" "'|='")
	       ("conditional_exp" "logical_or_exp")
	       ("conditional_exp" "logical_or_exp" "'?'" "exp" "':'" "conditional_exp")
	       ("const_exp" "conditional_exp")
	       ("logical_or_exp" "logical_and_exp")
	       ("logical_or_exp" "logical_or_exp" "'||'" "logical_and_exp")
	       ("logical_and_exp" "inclusive_or_exp")
	       ("logical_and_exp" "logical_and_exp" "'&&'" "inclusive_or_exp")
	       ("inclusive_or_exp" "exclusive_or_exp")
	       ("inclusive_or_exp" "inclusive_or_exp" "'|'" "exclusive_or_exp")
	       ("exclusive_or_exp" "and_exp")
	       ("exclusive_or_exp" "exclusive_or_exp" "'^'" "and_exp")
	       ("and_exp" "equality_exp")
	       ("and_exp" "and_exp" "'&'" "equality_exp")
	       ("equality_exp" "relational_exp")
	       ("equality_exp" "equality_exp" "'=='" "relational_exp")
	       ("equality_exp" "equality_exp" "'!='" "relational_exp")
	       ("relational_exp" "shift_expression")
	       ("relational_exp" "relational_exp" "'\<'" "shift_expression")
	       ("relational_exp" "relational_exp" "'\>'" "shift_expression")
	       ("relational_exp" "relational_exp" "'\<='" "shift_expression")
	       ("relational_exp" "relational_exp" "'\>='" "shift_expression")
	       ("shift_expression" "additive_exp")
	       ("shift_expression" "shift_expression" "'\<\<'" "additive_exp")
	       ("shift_expression" "shift_expression" "'\>\>'" "additive_exp")
	       ("additive_exp" "mult_exp")
	       ("additive_exp" "additive_exp" "'+'" "mult_exp")
	       ("additive_exp" "additive_exp" "'-'" "mult_exp")
	       ("mult_exp" "cast_exp")
	       ("mult_exp" "mult_exp" "'*'" "cast_exp")
	       ("mult_exp" "mult_exp" "'/'" "cast_exp")
	       ("mult_exp" "mult_exp" "'%'" "cast_exp")
	       ("cast_exp" "unary_exp")
	       ("cast_exp" "'('" "type_name" "')'" "cast_exp")
	       ("unary_exp" "postfix_exp")
	       ("unary_exp" "'++'" "unary_exp")
	       ("unary_exp" "'--'" "unary_exp")
	       ("unary_exp" "unary_operator" "cast_exp")
	       ("unary_exp" "'sizeof'" "unary_exp")
	       ("unary_exp" "'sizeof'" "'('" "type_name" "')'")
	       ("unary_operator" "'&'")
	       ("unary_operator" "'*'")
	       ("unary_operator" "'+'")
	       ("unary_operator" "'-'")
	       ("unary_operator" "'~'")
	       ("unary_operator" "'!'")
	       ("postfix_exp" "primary_exp")
	       ("postfix_exp" "postfix_exp" "'['" "exp" "']'")
	       ("postfix_exp" "postfix_exp" "'('" "argument_exp_list" "')'")
	       ("postfix_exp" "postfix_exp" "'('" "')'")
	       ("postfix_exp" "postfix_exp" "'.'" "id")
	       ("postfix_exp" "postfix_exp" "'-\>'" "id")
	       ("postfix_exp" "postfix_exp" "'++'")
	       ("postfix_exp" "postfix_exp" "'--'")
	       ("primary_exp" "id")
	       ("primary_exp" "const")
	       ("primary_exp" "string")
	       ("primary_exp" "'('" "exp" "')'")
	       ("argument_exp_list" "assignment_exp")
	       ("argument_exp_list" "argument_exp_list" "','" "assignment_exp")
	       ("const" "int_const")
	       ("const" "char_const")
	       ("const" "float_const")
	       ("const" "enumeration_const")
	       )))

(defparameter *cbnf-min*
  (mkgrammar "translation_unit"
	     '(("translation_unit" "external_decl")
	       ("translation_unit" "translation_unit" "external_decl")
	       ("external_decl" "function_definition")
	       ("external_decl" "decl")
	       ("function_definition" "decl_specs" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "decl_specs" "declarator" "compound_stat")
	       ("function_definition" "declarator" "compound_stat")
	       ("decl" "decl_specs" "init_declarator_list" "';'")
	       ("decl" "decl_specs" "';'")
	       ("decl_list" "decl")
	       ("decl_list" "decl_list" "decl")
	       ("storage_class_spec" "'auto'")
	       ("storage_class_spec" "'register'")
	       ("storage_class_spec" "'static'")
	       ("storage_class_spec" "'extern'")
	       ("storage_class_spec" "'typedef'")
	       ("type_qualifier" "'const'")
	       ("type_qualifier" "'volatile'")
	       ("struct_or_union_spec" "struct_or_union" "id" "'\{'" "struct_decl_list" "'\}'")
	       ("struct_or_union_spec" "struct_or_union" "'\{'" "struct_decl_list" "'\}'")
	       ("struct_or_union_spec" "struct_or_union" "id")
	       ("struct_or_union" "'struct'")
	       ("struct_or_union" "'union'")
	       ("struct_decl_list" "struct_decl")
	       ("struct_decl_list" "struct_decl_list" "struct_decl")
	       ("init_declarator_list" "init_declarator")
	       ("init_declarator_list" "init_declarator_list" "','" "init_declarator")
	       ("init_declarator" "declarator")
	       ("init_declarator" "declarator" "'='" "initializer")
	       ("struct_decl" "spec_qualifier_list" "struct_declarator_list" "';'")
	       ("spec_qualifier_list" "type_spec" "spec_qualifier_list")
	       ("spec_qualifier_list" "type_spec")
	       ("spec_qualifier_list" "type_qualifier" "spec_qualifier_list")
	       ("spec_qualifier_list" "type_qualifier")
	       ("struct_declarator_list" "struct_declarator")
	       ("struct_declarator_list" "struct_declarator_list" "','" "struct_declarator")
	       ("struct_declarator" "declarator")
	       ("struct_declarator" "declarator" "':'" "const_exp")
	       ("struct_declarator" "':'" "const_exp")
	       ("enum_spec" "'enum'" "id" "'\{'" "enumerator_list" "'\}'")
	       ("enum_spec" "'enum'" "'\{'" "enumerator_list" "'\}'")
	       ("enum_spec" "'enum'" "id")
	       ("enumerator_list" "enumerator")
	       ("enumerator_list" "enumerator_list" "','" "enumerator")
	       ("enumerator" "id")
	       ("enumerator" "id" "'='" "const_exp")
	       ("declarator" "pointer" "direct_declarator")
	       ("declarator" "direct_declarator")
	       ("pointer" "'*'" "type_qualifier_list")
	       ("pointer" "'*'")
	       ("pointer" "'*'" "type_qualifier_list" "pointer")
	       ("pointer" "'*'" "pointer")
	       ("type_qualifier_list" "type_qualifier")
	       ("type_qualifier_list" "type_qualifier_list" "type_qualifier")
	       ("param_type_list" "param_list")
	       ("param_type_list" "param_list" "','" "'...'")
	       ("param_list" "param_decl")
	       ("param_list" "param_list" "','" "param_decl")
	       ("param_decl" "decl_specs" "declarator")
	       ("param_decl" "decl_specs" "abstract_declarator")
	       ("param_decl" "decl_specs")
	       ("id_list" "id")
	       ("id_list" "id_list" "','" "id")
	       ("initializer_list" "initializer")
	       ("initializer_list" "initializer_list" "','" "initializer")
	       ("type_name" "spec_qualifier_list" "abstract_declarator")
	       ("type_name" "spec_qualifier_list")
	       ("abstract_declarator" "pointer")
	       ("abstract_declarator" "pointer" "direct_abstract_declarator")
	       ("abstract_declarator" "direct_abstract_declarator")
	       ("typedef_name" "id")
	       ("stat" "labeled_stat")
	       ("stat" "exp_stat")
	       ("stat" "compound_stat")
	       ("stat" "selection_stat")
	       ("stat" "iteration_stat")
	       ("stat" "jump_stat")
	       ("labeled_stat" "id" "':'" "stat")
	       ("labeled_stat" "'case'" "const_exp" "':'" "stat")
	       ("labeled_stat" "'default'" "':'" "stat")
	       ("exp_stat" "exp" "';'")
	       ("exp_stat" "';'")
	       ("compound_stat" "'\{'" "decl_list" "stat_list" "'\}'")
	       ("compound_stat" "'\{'" "stat_list" "'\}'")
	       ("compound_stat" "'\{'" "decl_list" "'\}'")
	       ("compound_stat" "'\{'" "'\}'")
	       ("stat_list" "stat")
	       ("stat_list" "stat_list" "stat")
	       ("jump_stat" "'goto'" "id" "';'")
	       ("jump_stat" "'continue'" "';'")
	       ("jump_stat" "'break'" "';'")
	       ("jump_stat" "'return'" "exp" "';'")
	       ("jump_stat" "'return'" "';'")
	       ("exp" "assignment_exp")
	       ("exp" "exp" "','" "assignment_exp")
	       ("assignment_exp" "conditional_exp")
	       ("assignment_exp" "unary_exp" "assignment_operator" "assignment_exp")
	       ("conditional_exp" "logical_or_exp")
	       ("conditional_exp" "logical_or_exp" "'?'" "exp" "':'" "conditional_exp")
	       ("const_exp" "conditional_exp")
	       ("equality_exp" "relational_exp")
	       ("equality_exp" "equality_exp" "'=='" "relational_exp")
	       ("equality_exp" "equality_exp" "'!='" "relational_exp")
	       ("shift_expression" "additive_exp")
	       ("shift_expression" "shift_expression" "'\<\<'" "additive_exp")
	       ("shift_expression" "shift_expression" "'\>\>'" "additive_exp")
	       ("additive_exp" "mult_exp")
	       ("additive_exp" "additive_exp" "'+'" "mult_exp")
	       ("additive_exp" "additive_exp" "'-'" "mult_exp")
	       ("mult_exp" "cast_exp")
	       ("mult_exp" "mult_exp" "'*'" "cast_exp")
	       ("mult_exp" "mult_exp" "'/'" "cast_exp")
	       ("mult_exp" "mult_exp" "'%'" "cast_exp")
	       ("cast_exp" "unary_exp")
	       ("cast_exp" "'('" "type_name" "')'" "cast_exp")
	       ("argument_exp_list" "assignment_exp")
	       ("argument_exp_list" "argument_exp_list" "','" "assignment_exp")
	       )))

(defparameter *cbnf-petit*
  (mkgrammar "translation_unit"
	     '(("translation_unit" "external_decl")
	       ("translation_unit" "translation_unit" "external_decl")
	       ("external_decl" "function_definition")
	       ("external_decl" "decl")
	       ("function_definition" "decl_specs" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "declarator" "decl_list" "compound_stat")
	       ("function_definition" "decl_specs" "declarator" "compound_stat")
	       ("function_definition" "declarator" "compound_stat")
	       ("decl" "decl_specs" "init_declarator_list" "';'")
	       ("decl" "decl_specs" "';'")
	       ("init_declarator_list" "init_declarator")
	       ("init_declarator_list" "init_declarator_list" "','" "init_declarator")
	       ("init_declarator" "declarator")
	       ("init_declarator" "declarator" "'='" "initializer")
	       ("struct_decl" "spec_qualifier_list" "struct_declarator_list" "';'")
	       ("struct_declarator_list" "struct_declarator")
	       ("struct_declarator_list" "struct_declarator_list" "','" "struct_declarator")
	       ("struct_declarator" "declarator")
	       ("struct_declarator" "declarator" "':'" "const_exp")
	       ("struct_declarator" "':'" "const_exp")
	       ("declarator" "pointer" "direct_declarator")
	       ("declarator" "direct_declarator")
	       ("pointer" "'*'" "type_qualifier_list")
	       ("pointer" "'*'")
	       ("pointer" "'*'" "type_qualifier_list" "pointer")
	       ("pointer" "'*'" "pointer")
	       ("type_qualifier_list" "type_qualifier")
	       ("type_qualifier_list" "type_qualifier_list" "type_qualifier")
	       ("param_type_list" "param_list")
	       ("param_type_list" "param_list" "','" "'...'")
	       ("param_list" "param_decl")
	       ("param_list" "param_list" "','" "param_decl")
	       ("param_decl" "decl_specs" "declarator")
	       ("param_decl" "decl_specs" "abstract_declarator")
	       ("param_decl" "decl_specs")
	       ("id_list" "id")
	       ("id_list" "id_list" "','" "id")
	       ("initializer_list" "initializer")
	       ("initializer_list" "initializer_list" "','" "initializer")
	       ("type_name" "spec_qualifier_list" "abstract_declarator")
	       ("type_name" "spec_qualifier_list")
	       ("typedef_name" "id")
	       ("labeled_stat" "id" "':'" "stat")
	       ("labeled_stat" "'case'" "const_exp" "':'" "stat")
	       ("labeled_stat" "'default'" "':'" "stat")
	       )))
